// Code generated by ent, DO NOT EDIT.

package file

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the file type in the database.
	Label = "file"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldBucketId holds the string denoting the bucketid field in the database.
	FieldBucketId = "bucketId"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldType holds the string denoting the type field in the database.
	FieldType = "type"
	// FieldHash holds the string denoting the hash field in the database.
	FieldHash = "hash"
	// FieldSize holds the string denoting the size field in the database.
	FieldSize = "size"
	// FieldPath holds the string denoting the path field in the database.
	FieldPath = "path"
	// FieldIsPublic holds the string denoting the ispublic field in the database.
	FieldIsPublic = "isPublic"
	// FieldUploadedBy holds the string denoting the uploadedby field in the database.
	FieldUploadedBy = "uploadedBy"
	// FieldDescription holds the string denoting the description field in the database.
	FieldDescription = "description"
	// FieldTags holds the string denoting the tags field in the database.
	FieldTags = "tags"
	// FieldCreatedAt holds the string denoting the createdat field in the database.
	FieldCreatedAt = "createdAt"
	// FieldUpdatedAt holds the string denoting the updatedat field in the database.
	FieldUpdatedAt = "updatedAt"
	// FieldExtraData holds the string denoting the extradata field in the database.
	FieldExtraData = "extraData"
	// FieldCategory holds the string denoting the category field in the database.
	FieldCategory = "category"
	// EdgeBucket holds the string denoting the bucket edge name in mutations.
	EdgeBucket = "bucket"
	// EdgeUser holds the string denoting the user edge name in mutations.
	EdgeUser = "user"
	// EdgeImageCompressed holds the string denoting the image_compressed edge name in mutations.
	EdgeImageCompressed = "Image_compressed"
	// EdgeImageOriginal holds the string denoting the image_original edge name in mutations.
	EdgeImageOriginal = "Image_original"
	// EdgeImageThumbnail320x holds the string denoting the image_thumbnail320x edge name in mutations.
	EdgeImageThumbnail320x = "Image_thumbnail320x"
	// EdgeImageThumbnail768x holds the string denoting the image_thumbnail768x edge name in mutations.
	EdgeImageThumbnail768x = "Image_thumbnail768x"
	// EdgeVideoFile holds the string denoting the video_file edge name in mutations.
	EdgeVideoFile = "Video_file"
	// EdgeVideoPoster holds the string denoting the video_poster edge name in mutations.
	EdgeVideoPoster = "Video_poster"
	// Table holds the table name of the file in the database.
	Table = "files"
	// BucketTable is the table that holds the bucket relation/edge.
	BucketTable = "files"
	// BucketInverseTable is the table name for the Bucket entity.
	// It exists in this package in order to avoid circular dependency with the "bucket" package.
	BucketInverseTable = "buckets"
	// BucketColumn is the table column denoting the bucket relation/edge.
	BucketColumn = "bucketId"
	// UserTable is the table that holds the user relation/edge.
	UserTable = "files"
	// UserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	UserInverseTable = "users"
	// UserColumn is the table column denoting the user relation/edge.
	UserColumn = "uploadedBy"
	// ImageCompressedTable is the table that holds the Image_compressed relation/edge.
	ImageCompressedTable = "images"
	// ImageCompressedInverseTable is the table name for the Image entity.
	// It exists in this package in order to avoid circular dependency with the "image" package.
	ImageCompressedInverseTable = "images"
	// ImageCompressedColumn is the table column denoting the Image_compressed relation/edge.
	ImageCompressedColumn = "compressed_id"
	// ImageOriginalTable is the table that holds the Image_original relation/edge.
	ImageOriginalTable = "images"
	// ImageOriginalInverseTable is the table name for the Image entity.
	// It exists in this package in order to avoid circular dependency with the "image" package.
	ImageOriginalInverseTable = "images"
	// ImageOriginalColumn is the table column denoting the Image_original relation/edge.
	ImageOriginalColumn = "original_id"
	// ImageThumbnail320xTable is the table that holds the Image_thumbnail320x relation/edge.
	ImageThumbnail320xTable = "images"
	// ImageThumbnail320xInverseTable is the table name for the Image entity.
	// It exists in this package in order to avoid circular dependency with the "image" package.
	ImageThumbnail320xInverseTable = "images"
	// ImageThumbnail320xColumn is the table column denoting the Image_thumbnail320x relation/edge.
	ImageThumbnail320xColumn = "thumbnail_320x_id"
	// ImageThumbnail768xTable is the table that holds the Image_thumbnail768x relation/edge.
	ImageThumbnail768xTable = "images"
	// ImageThumbnail768xInverseTable is the table name for the Image entity.
	// It exists in this package in order to avoid circular dependency with the "image" package.
	ImageThumbnail768xInverseTable = "images"
	// ImageThumbnail768xColumn is the table column denoting the Image_thumbnail768x relation/edge.
	ImageThumbnail768xColumn = "thumbnail_768x_id"
	// VideoFileTable is the table that holds the Video_file relation/edge.
	VideoFileTable = "videos"
	// VideoFileInverseTable is the table name for the Video entity.
	// It exists in this package in order to avoid circular dependency with the "video" package.
	VideoFileInverseTable = "videos"
	// VideoFileColumn is the table column denoting the Video_file relation/edge.
	VideoFileColumn = "fileId"
	// VideoPosterTable is the table that holds the Video_poster relation/edge.
	VideoPosterTable = "videos"
	// VideoPosterInverseTable is the table name for the Video entity.
	// It exists in this package in order to avoid circular dependency with the "video" package.
	VideoPosterInverseTable = "videos"
	// VideoPosterColumn is the table column denoting the Video_poster relation/edge.
	VideoPosterColumn = "posterId"
)

// Columns holds all SQL columns for file fields.
var Columns = []string{
	FieldID,
	FieldBucketId,
	FieldName,
	FieldType,
	FieldHash,
	FieldSize,
	FieldPath,
	FieldIsPublic,
	FieldUploadedBy,
	FieldDescription,
	FieldTags,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldExtraData,
	FieldCategory,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the File queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByBucketId orders the results by the bucketId field.
func ByBucketId(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBucketId, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByType orders the results by the type field.
func ByType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldType, opts...).ToFunc()
}

// ByHash orders the results by the hash field.
func ByHash(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldHash, opts...).ToFunc()
}

// BySize orders the results by the size field.
func BySize(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSize, opts...).ToFunc()
}

// ByPath orders the results by the path field.
func ByPath(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPath, opts...).ToFunc()
}

// ByIsPublic orders the results by the isPublic field.
func ByIsPublic(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsPublic, opts...).ToFunc()
}

// ByUploadedBy orders the results by the uploadedBy field.
func ByUploadedBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUploadedBy, opts...).ToFunc()
}

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDescription, opts...).ToFunc()
}

// ByCreatedAt orders the results by the createdAt field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updatedAt field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByCategory orders the results by the category field.
func ByCategory(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCategory, opts...).ToFunc()
}

// ByBucketField orders the results by bucket field.
func ByBucketField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newBucketStep(), sql.OrderByField(field, opts...))
	}
}

// ByUserField orders the results by user field.
func ByUserField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserStep(), sql.OrderByField(field, opts...))
	}
}

// ByImageCompressedCount orders the results by Image_compressed count.
func ByImageCompressedCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newImageCompressedStep(), opts...)
	}
}

// ByImageCompressed orders the results by Image_compressed terms.
func ByImageCompressed(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newImageCompressedStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByImageOriginalCount orders the results by Image_original count.
func ByImageOriginalCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newImageOriginalStep(), opts...)
	}
}

// ByImageOriginal orders the results by Image_original terms.
func ByImageOriginal(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newImageOriginalStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByImageThumbnail320xCount orders the results by Image_thumbnail320x count.
func ByImageThumbnail320xCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newImageThumbnail320xStep(), opts...)
	}
}

// ByImageThumbnail320x orders the results by Image_thumbnail320x terms.
func ByImageThumbnail320x(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newImageThumbnail320xStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByImageThumbnail768xCount orders the results by Image_thumbnail768x count.
func ByImageThumbnail768xCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newImageThumbnail768xStep(), opts...)
	}
}

// ByImageThumbnail768x orders the results by Image_thumbnail768x terms.
func ByImageThumbnail768x(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newImageThumbnail768xStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByVideoFileCount orders the results by Video_file count.
func ByVideoFileCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newVideoFileStep(), opts...)
	}
}

// ByVideoFile orders the results by Video_file terms.
func ByVideoFile(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newVideoFileStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByVideoPosterCount orders the results by Video_poster count.
func ByVideoPosterCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newVideoPosterStep(), opts...)
	}
}

// ByVideoPoster orders the results by Video_poster terms.
func ByVideoPoster(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newVideoPosterStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newBucketStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(BucketInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, BucketTable, BucketColumn),
	)
}
func newUserStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
	)
}
func newImageCompressedStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ImageCompressedInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ImageCompressedTable, ImageCompressedColumn),
	)
}
func newImageOriginalStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ImageOriginalInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ImageOriginalTable, ImageOriginalColumn),
	)
}
func newImageThumbnail320xStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ImageThumbnail320xInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ImageThumbnail320xTable, ImageThumbnail320xColumn),
	)
}
func newImageThumbnail768xStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ImageThumbnail768xInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ImageThumbnail768xTable, ImageThumbnail768xColumn),
	)
}
func newVideoFileStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(VideoFileInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, VideoFileTable, VideoFileColumn),
	)
}
func newVideoPosterStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(VideoPosterInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, VideoPosterTable, VideoPosterColumn),
	)
}
