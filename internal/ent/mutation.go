// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"api.us4ever/internal/ent/bucket"
	"api.us4ever/internal/ent/file"
	"api.us4ever/internal/ent/group"
	"api.us4ever/internal/ent/image"
	"api.us4ever/internal/ent/keep"
	"api.us4ever/internal/ent/mindmap"
	"api.us4ever/internal/ent/moment"
	"api.us4ever/internal/ent/momentimage"
	"api.us4ever/internal/ent/momentvideo"
	"api.us4ever/internal/ent/predicate"
	"api.us4ever/internal/ent/todo"
	"api.us4ever/internal/ent/user"
	"api.us4ever/internal/ent/video"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBucket      = "Bucket"
	TypeFile        = "File"
	TypeGroup       = "Group"
	TypeImage       = "Image"
	TypeKeep        = "Keep"
	TypeMindmap     = "Mindmap"
	TypeMoment      = "Moment"
	TypeMomentImage = "MomentImage"
	TypeMomentVideo = "MomentVideo"
	TypeTodo        = "Todo"
	TypeUser        = "User"
	TypeVideo       = "Video"
)

// BucketMutation represents an operation that mutates the Bucket nodes in the graph.
type BucketMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	bucketName      *string
	provider        *bucket.Provider
	region          *string
	endpoint        *string
	publicUrl       *string
	accessKey       *string
	secretKey       *string
	description     *string
	createdAt       *time.Time
	updatedAt       *time.Time
	extraData       *json.RawMessage
	appendextraData json.RawMessage
	category        *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	files           map[string]struct{}
	removedfiles    map[string]struct{}
	clearedfiles    bool
	done            bool
	oldValue        func(context.Context) (*Bucket, error)
	predicates      []predicate.Bucket
}

var _ ent.Mutation = (*BucketMutation)(nil)

// bucketOption allows management of the mutation configuration using functional options.
type bucketOption func(*BucketMutation)

// newBucketMutation creates new mutation for the Bucket entity.
func newBucketMutation(c config, op Op, opts ...bucketOption) *BucketMutation {
	m := &BucketMutation{
		config:        c,
		op:            op,
		typ:           TypeBucket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBucketID sets the ID field of the mutation.
func withBucketID(id string) bucketOption {
	return func(m *BucketMutation) {
		var (
			err   error
			once  sync.Once
			value *Bucket
		)
		m.oldValue = func(ctx context.Context) (*Bucket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bucket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBucket sets the old Bucket of the mutation.
func withBucket(node *Bucket) bucketOption {
	return func(m *BucketMutation) {
		m.oldValue = func(context.Context) (*Bucket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BucketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BucketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bucket entities.
func (m *BucketMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BucketMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BucketMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bucket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BucketMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BucketMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BucketMutation) ResetName() {
	m.name = nil
}

// SetBucketName sets the "bucketName" field.
func (m *BucketMutation) SetBucketName(s string) {
	m.bucketName = &s
}

// BucketName returns the value of the "bucketName" field in the mutation.
func (m *BucketMutation) BucketName() (r string, exists bool) {
	v := m.bucketName
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucketName" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldBucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ResetBucketName resets all changes to the "bucketName" field.
func (m *BucketMutation) ResetBucketName() {
	m.bucketName = nil
}

// SetProvider sets the "provider" field.
func (m *BucketMutation) SetProvider(b bucket.Provider) {
	m.provider = &b
}

// Provider returns the value of the "provider" field in the mutation.
func (m *BucketMutation) Provider() (r bucket.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldProvider(ctx context.Context) (v bucket.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *BucketMutation) ResetProvider() {
	m.provider = nil
}

// SetRegion sets the "region" field.
func (m *BucketMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *BucketMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *BucketMutation) ResetRegion() {
	m.region = nil
}

// SetEndpoint sets the "endpoint" field.
func (m *BucketMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *BucketMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *BucketMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetPublicUrl sets the "publicUrl" field.
func (m *BucketMutation) SetPublicUrl(s string) {
	m.publicUrl = &s
}

// PublicUrl returns the value of the "publicUrl" field in the mutation.
func (m *BucketMutation) PublicUrl() (r string, exists bool) {
	v := m.publicUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicUrl returns the old "publicUrl" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldPublicUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicUrl: %w", err)
	}
	return oldValue.PublicUrl, nil
}

// ResetPublicUrl resets all changes to the "publicUrl" field.
func (m *BucketMutation) ResetPublicUrl() {
	m.publicUrl = nil
}

// SetAccessKey sets the "accessKey" field.
func (m *BucketMutation) SetAccessKey(s string) {
	m.accessKey = &s
}

// AccessKey returns the value of the "accessKey" field in the mutation.
func (m *BucketMutation) AccessKey() (r string, exists bool) {
	v := m.accessKey
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessKey returns the old "accessKey" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldAccessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessKey: %w", err)
	}
	return oldValue.AccessKey, nil
}

// ResetAccessKey resets all changes to the "accessKey" field.
func (m *BucketMutation) ResetAccessKey() {
	m.accessKey = nil
}

// SetSecretKey sets the "secretKey" field.
func (m *BucketMutation) SetSecretKey(s string) {
	m.secretKey = &s
}

// SecretKey returns the value of the "secretKey" field in the mutation.
func (m *BucketMutation) SecretKey() (r string, exists bool) {
	v := m.secretKey
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secretKey" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ResetSecretKey resets all changes to the "secretKey" field.
func (m *BucketMutation) ResetSecretKey() {
	m.secretKey = nil
}

// SetDescription sets the "description" field.
func (m *BucketMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BucketMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BucketMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *BucketMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *BucketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *BucketMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *BucketMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *BucketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *BucketMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetOwnerId sets the "ownerId" field.
func (m *BucketMutation) SetOwnerId(s string) {
	m.user = &s
}

// OwnerId returns the value of the "ownerId" field in the mutation.
func (m *BucketMutation) OwnerId() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerId returns the old "ownerId" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldOwnerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerId: %w", err)
	}
	return oldValue.OwnerId, nil
}

// ClearOwnerId clears the value of the "ownerId" field.
func (m *BucketMutation) ClearOwnerId() {
	m.user = nil
	m.clearedFields[bucket.FieldOwnerId] = struct{}{}
}

// OwnerIdCleared returns if the "ownerId" field was cleared in this mutation.
func (m *BucketMutation) OwnerIdCleared() bool {
	_, ok := m.clearedFields[bucket.FieldOwnerId]
	return ok
}

// ResetOwnerId resets all changes to the "ownerId" field.
func (m *BucketMutation) ResetOwnerId() {
	m.user = nil
	delete(m.clearedFields, bucket.FieldOwnerId)
}

// SetExtraData sets the "extraData" field.
func (m *BucketMutation) SetExtraData(jm json.RawMessage) {
	m.extraData = &jm
	m.appendextraData = nil
}

// ExtraData returns the value of the "extraData" field in the mutation.
func (m *BucketMutation) ExtraData() (r json.RawMessage, exists bool) {
	v := m.extraData
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extraData" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldExtraData(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// AppendExtraData adds jm to the "extraData" field.
func (m *BucketMutation) AppendExtraData(jm json.RawMessage) {
	m.appendextraData = append(m.appendextraData, jm...)
}

// AppendedExtraData returns the list of values that were appended to the "extraData" field in this mutation.
func (m *BucketMutation) AppendedExtraData() (json.RawMessage, bool) {
	if len(m.appendextraData) == 0 {
		return nil, false
	}
	return m.appendextraData, true
}

// ResetExtraData resets all changes to the "extraData" field.
func (m *BucketMutation) ResetExtraData() {
	m.extraData = nil
	m.appendextraData = nil
}

// SetCategory sets the "category" field.
func (m *BucketMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *BucketMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Bucket entity.
// If the Bucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BucketMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *BucketMutation) ResetCategory() {
	m.category = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BucketMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BucketMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[bucket.FieldOwnerId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BucketMutation) UserCleared() bool {
	return m.OwnerIdCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BucketMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BucketMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BucketMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *BucketMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *BucketMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *BucketMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *BucketMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *BucketMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *BucketMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *BucketMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the BucketMutation builder.
func (m *BucketMutation) Where(ps ...predicate.Bucket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BucketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BucketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bucket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BucketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BucketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bucket).
func (m *BucketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BucketMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, bucket.FieldName)
	}
	if m.bucketName != nil {
		fields = append(fields, bucket.FieldBucketName)
	}
	if m.provider != nil {
		fields = append(fields, bucket.FieldProvider)
	}
	if m.region != nil {
		fields = append(fields, bucket.FieldRegion)
	}
	if m.endpoint != nil {
		fields = append(fields, bucket.FieldEndpoint)
	}
	if m.publicUrl != nil {
		fields = append(fields, bucket.FieldPublicUrl)
	}
	if m.accessKey != nil {
		fields = append(fields, bucket.FieldAccessKey)
	}
	if m.secretKey != nil {
		fields = append(fields, bucket.FieldSecretKey)
	}
	if m.description != nil {
		fields = append(fields, bucket.FieldDescription)
	}
	if m.createdAt != nil {
		fields = append(fields, bucket.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, bucket.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, bucket.FieldOwnerId)
	}
	if m.extraData != nil {
		fields = append(fields, bucket.FieldExtraData)
	}
	if m.category != nil {
		fields = append(fields, bucket.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BucketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bucket.FieldName:
		return m.Name()
	case bucket.FieldBucketName:
		return m.BucketName()
	case bucket.FieldProvider:
		return m.Provider()
	case bucket.FieldRegion:
		return m.Region()
	case bucket.FieldEndpoint:
		return m.Endpoint()
	case bucket.FieldPublicUrl:
		return m.PublicUrl()
	case bucket.FieldAccessKey:
		return m.AccessKey()
	case bucket.FieldSecretKey:
		return m.SecretKey()
	case bucket.FieldDescription:
		return m.Description()
	case bucket.FieldCreatedAt:
		return m.CreatedAt()
	case bucket.FieldUpdatedAt:
		return m.UpdatedAt()
	case bucket.FieldOwnerId:
		return m.OwnerId()
	case bucket.FieldExtraData:
		return m.ExtraData()
	case bucket.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BucketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bucket.FieldName:
		return m.OldName(ctx)
	case bucket.FieldBucketName:
		return m.OldBucketName(ctx)
	case bucket.FieldProvider:
		return m.OldProvider(ctx)
	case bucket.FieldRegion:
		return m.OldRegion(ctx)
	case bucket.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case bucket.FieldPublicUrl:
		return m.OldPublicUrl(ctx)
	case bucket.FieldAccessKey:
		return m.OldAccessKey(ctx)
	case bucket.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case bucket.FieldDescription:
		return m.OldDescription(ctx)
	case bucket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bucket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bucket.FieldOwnerId:
		return m.OldOwnerId(ctx)
	case bucket.FieldExtraData:
		return m.OldExtraData(ctx)
	case bucket.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Bucket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BucketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bucket.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bucket.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case bucket.FieldProvider:
		v, ok := value.(bucket.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case bucket.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case bucket.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case bucket.FieldPublicUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicUrl(v)
		return nil
	case bucket.FieldAccessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessKey(v)
		return nil
	case bucket.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case bucket.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case bucket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bucket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bucket.FieldOwnerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerId(v)
		return nil
	case bucket.FieldExtraData:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case bucket.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Bucket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BucketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BucketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BucketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bucket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BucketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bucket.FieldOwnerId) {
		fields = append(fields, bucket.FieldOwnerId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BucketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BucketMutation) ClearField(name string) error {
	switch name {
	case bucket.FieldOwnerId:
		m.ClearOwnerId()
		return nil
	}
	return fmt.Errorf("unknown Bucket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BucketMutation) ResetField(name string) error {
	switch name {
	case bucket.FieldName:
		m.ResetName()
		return nil
	case bucket.FieldBucketName:
		m.ResetBucketName()
		return nil
	case bucket.FieldProvider:
		m.ResetProvider()
		return nil
	case bucket.FieldRegion:
		m.ResetRegion()
		return nil
	case bucket.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case bucket.FieldPublicUrl:
		m.ResetPublicUrl()
		return nil
	case bucket.FieldAccessKey:
		m.ResetAccessKey()
		return nil
	case bucket.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case bucket.FieldDescription:
		m.ResetDescription()
		return nil
	case bucket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bucket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bucket.FieldOwnerId:
		m.ResetOwnerId()
		return nil
	case bucket.FieldExtraData:
		m.ResetExtraData()
		return nil
	case bucket.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Bucket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BucketMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, bucket.EdgeUser)
	}
	if m.files != nil {
		edges = append(edges, bucket.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BucketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bucket.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case bucket.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BucketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfiles != nil {
		edges = append(edges, bucket.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BucketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bucket.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BucketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, bucket.EdgeUser)
	}
	if m.clearedfiles {
		edges = append(edges, bucket.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BucketMutation) EdgeCleared(name string) bool {
	switch name {
	case bucket.EdgeUser:
		return m.cleareduser
	case bucket.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BucketMutation) ClearEdge(name string) error {
	switch name {
	case bucket.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Bucket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BucketMutation) ResetEdge(name string) error {
	switch name {
	case bucket.EdgeUser:
		m.ResetUser()
		return nil
	case bucket.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Bucket edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	name                        *string
	_type                       *string
	hash                        *string
	size                        *int
	addsize                     *int
	_path                       *string
	isPublic                    *bool
	description                 *string
	tags                        *json.RawMessage
	appendtags                  json.RawMessage
	createdAt                   *time.Time
	updatedAt                   *time.Time
	extraData                   *json.RawMessage
	appendextraData             json.RawMessage
	category                    *string
	clearedFields               map[string]struct{}
	bucket                      *string
	clearedbucket               bool
	user                        *string
	cleareduser                 bool
	_Image_compressed           map[string]struct{}
	removed_Image_compressed    map[string]struct{}
	cleared_Image_compressed    bool
	_Image_original             map[string]struct{}
	removed_Image_original      map[string]struct{}
	cleared_Image_original      bool
	_Image_thumbnail320x        map[string]struct{}
	removed_Image_thumbnail320x map[string]struct{}
	cleared_Image_thumbnail320x bool
	_Image_thumbnail768x        map[string]struct{}
	removed_Image_thumbnail768x map[string]struct{}
	cleared_Image_thumbnail768x bool
	_Video_file                 map[string]struct{}
	removed_Video_file          map[string]struct{}
	cleared_Video_file          bool
	_Video_poster               map[string]struct{}
	removed_Video_poster        map[string]struct{}
	cleared_Video_poster        bool
	done                        bool
	oldValue                    func(context.Context) (*File, error)
	predicates                  []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id string) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBucketId sets the "bucketId" field.
func (m *FileMutation) SetBucketId(s string) {
	m.bucket = &s
}

// BucketId returns the value of the "bucketId" field in the mutation.
func (m *FileMutation) BucketId() (r string, exists bool) {
	v := m.bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketId returns the old "bucketId" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldBucketId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketId: %w", err)
	}
	return oldValue.BucketId, nil
}

// ClearBucketId clears the value of the "bucketId" field.
func (m *FileMutation) ClearBucketId() {
	m.bucket = nil
	m.clearedFields[file.FieldBucketId] = struct{}{}
}

// BucketIdCleared returns if the "bucketId" field was cleared in this mutation.
func (m *FileMutation) BucketIdCleared() bool {
	_, ok := m.clearedFields[file.FieldBucketId]
	return ok
}

// ResetBucketId resets all changes to the "bucketId" field.
func (m *FileMutation) ResetBucketId() {
	m.bucket = nil
	delete(m.clearedFields, file.FieldBucketId)
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetHash sets the "hash" field.
func (m *FileMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *FileMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *FileMutation) ResetHash() {
	m.hash = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetIsPublic sets the "isPublic" field.
func (m *FileMutation) SetIsPublic(b bool) {
	m.isPublic = &b
}

// IsPublic returns the value of the "isPublic" field in the mutation.
func (m *FileMutation) IsPublic() (r bool, exists bool) {
	v := m.isPublic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "isPublic" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "isPublic" field.
func (m *FileMutation) ResetIsPublic() {
	m.isPublic = nil
}

// SetUploadedBy sets the "uploadedBy" field.
func (m *FileMutation) SetUploadedBy(s string) {
	m.user = &s
}

// UploadedBy returns the value of the "uploadedBy" field in the mutation.
func (m *FileMutation) UploadedBy() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedBy returns the old "uploadedBy" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUploadedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedBy: %w", err)
	}
	return oldValue.UploadedBy, nil
}

// ClearUploadedBy clears the value of the "uploadedBy" field.
func (m *FileMutation) ClearUploadedBy() {
	m.user = nil
	m.clearedFields[file.FieldUploadedBy] = struct{}{}
}

// UploadedByCleared returns if the "uploadedBy" field was cleared in this mutation.
func (m *FileMutation) UploadedByCleared() bool {
	_, ok := m.clearedFields[file.FieldUploadedBy]
	return ok
}

// ResetUploadedBy resets all changes to the "uploadedBy" field.
func (m *FileMutation) ResetUploadedBy() {
	m.user = nil
	delete(m.clearedFields, file.FieldUploadedBy)
}

// SetDescription sets the "description" field.
func (m *FileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FileMutation) ResetDescription() {
	m.description = nil
}

// SetTags sets the "tags" field.
func (m *FileMutation) SetTags(jm json.RawMessage) {
	m.tags = &jm
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileMutation) Tags() (r json.RawMessage, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldTags(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds jm to the "tags" field.
func (m *FileMutation) AppendTags(jm json.RawMessage) {
	m.appendtags = append(m.appendtags, jm...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *FileMutation) AppendedTags() (json.RawMessage, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *FileMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *FileMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetExtraData sets the "extraData" field.
func (m *FileMutation) SetExtraData(jm json.RawMessage) {
	m.extraData = &jm
	m.appendextraData = nil
}

// ExtraData returns the value of the "extraData" field in the mutation.
func (m *FileMutation) ExtraData() (r json.RawMessage, exists bool) {
	v := m.extraData
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extraData" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldExtraData(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// AppendExtraData adds jm to the "extraData" field.
func (m *FileMutation) AppendExtraData(jm json.RawMessage) {
	m.appendextraData = append(m.appendextraData, jm...)
}

// AppendedExtraData returns the list of values that were appended to the "extraData" field in this mutation.
func (m *FileMutation) AppendedExtraData() (json.RawMessage, bool) {
	if len(m.appendextraData) == 0 {
		return nil, false
	}
	return m.appendextraData, true
}

// ResetExtraData resets all changes to the "extraData" field.
func (m *FileMutation) ResetExtraData() {
	m.extraData = nil
	m.appendextraData = nil
}

// SetCategory sets the "category" field.
func (m *FileMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FileMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FileMutation) ResetCategory() {
	m.category = nil
}

// SetBucketID sets the "bucket" edge to the Bucket entity by id.
func (m *FileMutation) SetBucketID(id string) {
	m.bucket = &id
}

// ClearBucket clears the "bucket" edge to the Bucket entity.
func (m *FileMutation) ClearBucket() {
	m.clearedbucket = true
	m.clearedFields[file.FieldBucketId] = struct{}{}
}

// BucketCleared reports if the "bucket" edge to the Bucket entity was cleared.
func (m *FileMutation) BucketCleared() bool {
	return m.BucketIdCleared() || m.clearedbucket
}

// BucketID returns the "bucket" edge ID in the mutation.
func (m *FileMutation) BucketID() (id string, exists bool) {
	if m.bucket != nil {
		return *m.bucket, true
	}
	return
}

// BucketIDs returns the "bucket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BucketID instead. It exists only for internal usage by the builders.
func (m *FileMutation) BucketIDs() (ids []string) {
	if id := m.bucket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBucket resets all changes to the "bucket" edge.
func (m *FileMutation) ResetBucket() {
	m.bucket = nil
	m.clearedbucket = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *FileMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *FileMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[file.FieldUploadedBy] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FileMutation) UserCleared() bool {
	return m.UploadedByCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *FileMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FileMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddImageCompressedIDs adds the "Image_compressed" edge to the Image entity by ids.
func (m *FileMutation) AddImageCompressedIDs(ids ...string) {
	if m._Image_compressed == nil {
		m._Image_compressed = make(map[string]struct{})
	}
	for i := range ids {
		m._Image_compressed[ids[i]] = struct{}{}
	}
}

// ClearImageCompressed clears the "Image_compressed" edge to the Image entity.
func (m *FileMutation) ClearImageCompressed() {
	m.cleared_Image_compressed = true
}

// ImageCompressedCleared reports if the "Image_compressed" edge to the Image entity was cleared.
func (m *FileMutation) ImageCompressedCleared() bool {
	return m.cleared_Image_compressed
}

// RemoveImageCompressedIDs removes the "Image_compressed" edge to the Image entity by IDs.
func (m *FileMutation) RemoveImageCompressedIDs(ids ...string) {
	if m.removed_Image_compressed == nil {
		m.removed_Image_compressed = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Image_compressed, ids[i])
		m.removed_Image_compressed[ids[i]] = struct{}{}
	}
}

// RemovedImageCompressed returns the removed IDs of the "Image_compressed" edge to the Image entity.
func (m *FileMutation) RemovedImageCompressedIDs() (ids []string) {
	for id := range m.removed_Image_compressed {
		ids = append(ids, id)
	}
	return
}

// ImageCompressedIDs returns the "Image_compressed" edge IDs in the mutation.
func (m *FileMutation) ImageCompressedIDs() (ids []string) {
	for id := range m._Image_compressed {
		ids = append(ids, id)
	}
	return
}

// ResetImageCompressed resets all changes to the "Image_compressed" edge.
func (m *FileMutation) ResetImageCompressed() {
	m._Image_compressed = nil
	m.cleared_Image_compressed = false
	m.removed_Image_compressed = nil
}

// AddImageOriginalIDs adds the "Image_original" edge to the Image entity by ids.
func (m *FileMutation) AddImageOriginalIDs(ids ...string) {
	if m._Image_original == nil {
		m._Image_original = make(map[string]struct{})
	}
	for i := range ids {
		m._Image_original[ids[i]] = struct{}{}
	}
}

// ClearImageOriginal clears the "Image_original" edge to the Image entity.
func (m *FileMutation) ClearImageOriginal() {
	m.cleared_Image_original = true
}

// ImageOriginalCleared reports if the "Image_original" edge to the Image entity was cleared.
func (m *FileMutation) ImageOriginalCleared() bool {
	return m.cleared_Image_original
}

// RemoveImageOriginalIDs removes the "Image_original" edge to the Image entity by IDs.
func (m *FileMutation) RemoveImageOriginalIDs(ids ...string) {
	if m.removed_Image_original == nil {
		m.removed_Image_original = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Image_original, ids[i])
		m.removed_Image_original[ids[i]] = struct{}{}
	}
}

// RemovedImageOriginal returns the removed IDs of the "Image_original" edge to the Image entity.
func (m *FileMutation) RemovedImageOriginalIDs() (ids []string) {
	for id := range m.removed_Image_original {
		ids = append(ids, id)
	}
	return
}

// ImageOriginalIDs returns the "Image_original" edge IDs in the mutation.
func (m *FileMutation) ImageOriginalIDs() (ids []string) {
	for id := range m._Image_original {
		ids = append(ids, id)
	}
	return
}

// ResetImageOriginal resets all changes to the "Image_original" edge.
func (m *FileMutation) ResetImageOriginal() {
	m._Image_original = nil
	m.cleared_Image_original = false
	m.removed_Image_original = nil
}

// AddImageThumbnail320xIDs adds the "Image_thumbnail320x" edge to the Image entity by ids.
func (m *FileMutation) AddImageThumbnail320xIDs(ids ...string) {
	if m._Image_thumbnail320x == nil {
		m._Image_thumbnail320x = make(map[string]struct{})
	}
	for i := range ids {
		m._Image_thumbnail320x[ids[i]] = struct{}{}
	}
}

// ClearImageThumbnail320x clears the "Image_thumbnail320x" edge to the Image entity.
func (m *FileMutation) ClearImageThumbnail320x() {
	m.cleared_Image_thumbnail320x = true
}

// ImageThumbnail320xCleared reports if the "Image_thumbnail320x" edge to the Image entity was cleared.
func (m *FileMutation) ImageThumbnail320xCleared() bool {
	return m.cleared_Image_thumbnail320x
}

// RemoveImageThumbnail320xIDs removes the "Image_thumbnail320x" edge to the Image entity by IDs.
func (m *FileMutation) RemoveImageThumbnail320xIDs(ids ...string) {
	if m.removed_Image_thumbnail320x == nil {
		m.removed_Image_thumbnail320x = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Image_thumbnail320x, ids[i])
		m.removed_Image_thumbnail320x[ids[i]] = struct{}{}
	}
}

// RemovedImageThumbnail320x returns the removed IDs of the "Image_thumbnail320x" edge to the Image entity.
func (m *FileMutation) RemovedImageThumbnail320xIDs() (ids []string) {
	for id := range m.removed_Image_thumbnail320x {
		ids = append(ids, id)
	}
	return
}

// ImageThumbnail320xIDs returns the "Image_thumbnail320x" edge IDs in the mutation.
func (m *FileMutation) ImageThumbnail320xIDs() (ids []string) {
	for id := range m._Image_thumbnail320x {
		ids = append(ids, id)
	}
	return
}

// ResetImageThumbnail320x resets all changes to the "Image_thumbnail320x" edge.
func (m *FileMutation) ResetImageThumbnail320x() {
	m._Image_thumbnail320x = nil
	m.cleared_Image_thumbnail320x = false
	m.removed_Image_thumbnail320x = nil
}

// AddImageThumbnail768xIDs adds the "Image_thumbnail768x" edge to the Image entity by ids.
func (m *FileMutation) AddImageThumbnail768xIDs(ids ...string) {
	if m._Image_thumbnail768x == nil {
		m._Image_thumbnail768x = make(map[string]struct{})
	}
	for i := range ids {
		m._Image_thumbnail768x[ids[i]] = struct{}{}
	}
}

// ClearImageThumbnail768x clears the "Image_thumbnail768x" edge to the Image entity.
func (m *FileMutation) ClearImageThumbnail768x() {
	m.cleared_Image_thumbnail768x = true
}

// ImageThumbnail768xCleared reports if the "Image_thumbnail768x" edge to the Image entity was cleared.
func (m *FileMutation) ImageThumbnail768xCleared() bool {
	return m.cleared_Image_thumbnail768x
}

// RemoveImageThumbnail768xIDs removes the "Image_thumbnail768x" edge to the Image entity by IDs.
func (m *FileMutation) RemoveImageThumbnail768xIDs(ids ...string) {
	if m.removed_Image_thumbnail768x == nil {
		m.removed_Image_thumbnail768x = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Image_thumbnail768x, ids[i])
		m.removed_Image_thumbnail768x[ids[i]] = struct{}{}
	}
}

// RemovedImageThumbnail768x returns the removed IDs of the "Image_thumbnail768x" edge to the Image entity.
func (m *FileMutation) RemovedImageThumbnail768xIDs() (ids []string) {
	for id := range m.removed_Image_thumbnail768x {
		ids = append(ids, id)
	}
	return
}

// ImageThumbnail768xIDs returns the "Image_thumbnail768x" edge IDs in the mutation.
func (m *FileMutation) ImageThumbnail768xIDs() (ids []string) {
	for id := range m._Image_thumbnail768x {
		ids = append(ids, id)
	}
	return
}

// ResetImageThumbnail768x resets all changes to the "Image_thumbnail768x" edge.
func (m *FileMutation) ResetImageThumbnail768x() {
	m._Image_thumbnail768x = nil
	m.cleared_Image_thumbnail768x = false
	m.removed_Image_thumbnail768x = nil
}

// AddVideoFileIDs adds the "Video_file" edge to the Video entity by ids.
func (m *FileMutation) AddVideoFileIDs(ids ...string) {
	if m._Video_file == nil {
		m._Video_file = make(map[string]struct{})
	}
	for i := range ids {
		m._Video_file[ids[i]] = struct{}{}
	}
}

// ClearVideoFile clears the "Video_file" edge to the Video entity.
func (m *FileMutation) ClearVideoFile() {
	m.cleared_Video_file = true
}

// VideoFileCleared reports if the "Video_file" edge to the Video entity was cleared.
func (m *FileMutation) VideoFileCleared() bool {
	return m.cleared_Video_file
}

// RemoveVideoFileIDs removes the "Video_file" edge to the Video entity by IDs.
func (m *FileMutation) RemoveVideoFileIDs(ids ...string) {
	if m.removed_Video_file == nil {
		m.removed_Video_file = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Video_file, ids[i])
		m.removed_Video_file[ids[i]] = struct{}{}
	}
}

// RemovedVideoFile returns the removed IDs of the "Video_file" edge to the Video entity.
func (m *FileMutation) RemovedVideoFileIDs() (ids []string) {
	for id := range m.removed_Video_file {
		ids = append(ids, id)
	}
	return
}

// VideoFileIDs returns the "Video_file" edge IDs in the mutation.
func (m *FileMutation) VideoFileIDs() (ids []string) {
	for id := range m._Video_file {
		ids = append(ids, id)
	}
	return
}

// ResetVideoFile resets all changes to the "Video_file" edge.
func (m *FileMutation) ResetVideoFile() {
	m._Video_file = nil
	m.cleared_Video_file = false
	m.removed_Video_file = nil
}

// AddVideoPosterIDs adds the "Video_poster" edge to the Video entity by ids.
func (m *FileMutation) AddVideoPosterIDs(ids ...string) {
	if m._Video_poster == nil {
		m._Video_poster = make(map[string]struct{})
	}
	for i := range ids {
		m._Video_poster[ids[i]] = struct{}{}
	}
}

// ClearVideoPoster clears the "Video_poster" edge to the Video entity.
func (m *FileMutation) ClearVideoPoster() {
	m.cleared_Video_poster = true
}

// VideoPosterCleared reports if the "Video_poster" edge to the Video entity was cleared.
func (m *FileMutation) VideoPosterCleared() bool {
	return m.cleared_Video_poster
}

// RemoveVideoPosterIDs removes the "Video_poster" edge to the Video entity by IDs.
func (m *FileMutation) RemoveVideoPosterIDs(ids ...string) {
	if m.removed_Video_poster == nil {
		m.removed_Video_poster = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Video_poster, ids[i])
		m.removed_Video_poster[ids[i]] = struct{}{}
	}
}

// RemovedVideoPoster returns the removed IDs of the "Video_poster" edge to the Video entity.
func (m *FileMutation) RemovedVideoPosterIDs() (ids []string) {
	for id := range m.removed_Video_poster {
		ids = append(ids, id)
	}
	return
}

// VideoPosterIDs returns the "Video_poster" edge IDs in the mutation.
func (m *FileMutation) VideoPosterIDs() (ids []string) {
	for id := range m._Video_poster {
		ids = append(ids, id)
	}
	return
}

// ResetVideoPoster resets all changes to the "Video_poster" edge.
func (m *FileMutation) ResetVideoPoster() {
	m._Video_poster = nil
	m.cleared_Video_poster = false
	m.removed_Video_poster = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.bucket != nil {
		fields = append(fields, file.FieldBucketId)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.hash != nil {
		fields = append(fields, file.FieldHash)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.isPublic != nil {
		fields = append(fields, file.FieldIsPublic)
	}
	if m.user != nil {
		fields = append(fields, file.FieldUploadedBy)
	}
	if m.description != nil {
		fields = append(fields, file.FieldDescription)
	}
	if m.tags != nil {
		fields = append(fields, file.FieldTags)
	}
	if m.createdAt != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.extraData != nil {
		fields = append(fields, file.FieldExtraData)
	}
	if m.category != nil {
		fields = append(fields, file.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldBucketId:
		return m.BucketId()
	case file.FieldName:
		return m.Name()
	case file.FieldType:
		return m.GetType()
	case file.FieldHash:
		return m.Hash()
	case file.FieldSize:
		return m.Size()
	case file.FieldPath:
		return m.Path()
	case file.FieldIsPublic:
		return m.IsPublic()
	case file.FieldUploadedBy:
		return m.UploadedBy()
	case file.FieldDescription:
		return m.Description()
	case file.FieldTags:
		return m.Tags()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldExtraData:
		return m.ExtraData()
	case file.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldBucketId:
		return m.OldBucketId(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldHash:
		return m.OldHash(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case file.FieldUploadedBy:
		return m.OldUploadedBy(ctx)
	case file.FieldDescription:
		return m.OldDescription(ctx)
	case file.FieldTags:
		return m.OldTags(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldExtraData:
		return m.OldExtraData(ctx)
	case file.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldBucketId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketId(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case file.FieldUploadedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedBy(v)
		return nil
	case file.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case file.FieldTags:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldExtraData:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case file.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldBucketId) {
		fields = append(fields, file.FieldBucketId)
	}
	if m.FieldCleared(file.FieldUploadedBy) {
		fields = append(fields, file.FieldUploadedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldBucketId:
		m.ClearBucketId()
		return nil
	case file.FieldUploadedBy:
		m.ClearUploadedBy()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldBucketId:
		m.ResetBucketId()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldHash:
		m.ResetHash()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case file.FieldUploadedBy:
		m.ResetUploadedBy()
		return nil
	case file.FieldDescription:
		m.ResetDescription()
		return nil
	case file.FieldTags:
		m.ResetTags()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldExtraData:
		m.ResetExtraData()
		return nil
	case file.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.bucket != nil {
		edges = append(edges, file.EdgeBucket)
	}
	if m.user != nil {
		edges = append(edges, file.EdgeUser)
	}
	if m._Image_compressed != nil {
		edges = append(edges, file.EdgeImageCompressed)
	}
	if m._Image_original != nil {
		edges = append(edges, file.EdgeImageOriginal)
	}
	if m._Image_thumbnail320x != nil {
		edges = append(edges, file.EdgeImageThumbnail320x)
	}
	if m._Image_thumbnail768x != nil {
		edges = append(edges, file.EdgeImageThumbnail768x)
	}
	if m._Video_file != nil {
		edges = append(edges, file.EdgeVideoFile)
	}
	if m._Video_poster != nil {
		edges = append(edges, file.EdgeVideoPoster)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeBucket:
		if id := m.bucket; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeImageCompressed:
		ids := make([]ent.Value, 0, len(m._Image_compressed))
		for id := range m._Image_compressed {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeImageOriginal:
		ids := make([]ent.Value, 0, len(m._Image_original))
		for id := range m._Image_original {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeImageThumbnail320x:
		ids := make([]ent.Value, 0, len(m._Image_thumbnail320x))
		for id := range m._Image_thumbnail320x {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeImageThumbnail768x:
		ids := make([]ent.Value, 0, len(m._Image_thumbnail768x))
		for id := range m._Image_thumbnail768x {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeVideoFile:
		ids := make([]ent.Value, 0, len(m._Video_file))
		for id := range m._Video_file {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeVideoPoster:
		ids := make([]ent.Value, 0, len(m._Video_poster))
		for id := range m._Video_poster {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removed_Image_compressed != nil {
		edges = append(edges, file.EdgeImageCompressed)
	}
	if m.removed_Image_original != nil {
		edges = append(edges, file.EdgeImageOriginal)
	}
	if m.removed_Image_thumbnail320x != nil {
		edges = append(edges, file.EdgeImageThumbnail320x)
	}
	if m.removed_Image_thumbnail768x != nil {
		edges = append(edges, file.EdgeImageThumbnail768x)
	}
	if m.removed_Video_file != nil {
		edges = append(edges, file.EdgeVideoFile)
	}
	if m.removed_Video_poster != nil {
		edges = append(edges, file.EdgeVideoPoster)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeImageCompressed:
		ids := make([]ent.Value, 0, len(m.removed_Image_compressed))
		for id := range m.removed_Image_compressed {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeImageOriginal:
		ids := make([]ent.Value, 0, len(m.removed_Image_original))
		for id := range m.removed_Image_original {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeImageThumbnail320x:
		ids := make([]ent.Value, 0, len(m.removed_Image_thumbnail320x))
		for id := range m.removed_Image_thumbnail320x {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeImageThumbnail768x:
		ids := make([]ent.Value, 0, len(m.removed_Image_thumbnail768x))
		for id := range m.removed_Image_thumbnail768x {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeVideoFile:
		ids := make([]ent.Value, 0, len(m.removed_Video_file))
		for id := range m.removed_Video_file {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeVideoPoster:
		ids := make([]ent.Value, 0, len(m.removed_Video_poster))
		for id := range m.removed_Video_poster {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbucket {
		edges = append(edges, file.EdgeBucket)
	}
	if m.cleareduser {
		edges = append(edges, file.EdgeUser)
	}
	if m.cleared_Image_compressed {
		edges = append(edges, file.EdgeImageCompressed)
	}
	if m.cleared_Image_original {
		edges = append(edges, file.EdgeImageOriginal)
	}
	if m.cleared_Image_thumbnail320x {
		edges = append(edges, file.EdgeImageThumbnail320x)
	}
	if m.cleared_Image_thumbnail768x {
		edges = append(edges, file.EdgeImageThumbnail768x)
	}
	if m.cleared_Video_file {
		edges = append(edges, file.EdgeVideoFile)
	}
	if m.cleared_Video_poster {
		edges = append(edges, file.EdgeVideoPoster)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeBucket:
		return m.clearedbucket
	case file.EdgeUser:
		return m.cleareduser
	case file.EdgeImageCompressed:
		return m.cleared_Image_compressed
	case file.EdgeImageOriginal:
		return m.cleared_Image_original
	case file.EdgeImageThumbnail320x:
		return m.cleared_Image_thumbnail320x
	case file.EdgeImageThumbnail768x:
		return m.cleared_Image_thumbnail768x
	case file.EdgeVideoFile:
		return m.cleared_Video_file
	case file.EdgeVideoPoster:
		return m.cleared_Video_poster
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeBucket:
		m.ClearBucket()
		return nil
	case file.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeBucket:
		m.ResetBucket()
		return nil
	case file.EdgeUser:
		m.ResetUser()
		return nil
	case file.EdgeImageCompressed:
		m.ResetImageCompressed()
		return nil
	case file.EdgeImageOriginal:
		m.ResetImageOriginal()
		return nil
	case file.EdgeImageThumbnail320x:
		m.ResetImageThumbnail320x()
		return nil
	case file.EdgeImageThumbnail768x:
		m.ResetImageThumbnail768x()
		return nil
	case file.EdgeVideoFile:
		m.ResetVideoFile()
		return nil
	case file.EdgeVideoPoster:
		m.ResetVideoPoster()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	description   *string
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	users         map[string]struct{}
	removedusers  map[string]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Group, error)
	predicates    []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id string) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.description != nil {
		fields = append(fields, group.FieldDescription)
	}
	if m.createdAt != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldName:
		return m.Name()
	case group.FieldDescription:
		return m.Description()
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	_type                    *string
	size                     *int
	addsize                  *int
	width                    *int32
	addwidth                 *int32
	height                   *int32
	addheight                *int32
	exif                     *json.RawMessage
	appendexif               json.RawMessage
	hash                     *string
	address                  *string
	isPublic                 *bool
	description              *string
	tags                     *json.RawMessage
	appendtags               json.RawMessage
	thumbnail_10x            *[]byte
	createdAt                *time.Time
	updatedAt                *time.Time
	category                 *string
	extraData                *json.RawMessage
	appendextraData          json.RawMessage
	description_vector       *json.RawMessage
	appenddescription_vector json.RawMessage
	clearedFields            map[string]struct{}
	compressed               *string
	clearedcompressed        bool
	original                 *string
	clearedoriginal          bool
	thumbnail320x            *string
	clearedthumbnail320x     bool
	thumbnail768x            *string
	clearedthumbnail768x     bool
	user                     *string
	cleareduser              bool
	moment_images            map[uint]struct{}
	removedmoment_images     map[uint]struct{}
	clearedmoment_images     bool
	done                     bool
	oldValue                 func(context.Context) (*Image, error)
	predicates               []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id string) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImageMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ImageMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ImageMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ImageMutation) ResetType() {
	m._type = nil
}

// SetSize sets the "size" field.
func (m *ImageMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *ImageMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *ImageMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *ImageMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *ImageMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetWidth sets the "width" field.
func (m *ImageMutation) SetWidth(i int32) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ImageMutation) Width() (r int32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *ImageMutation) AddWidth(i int32) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ImageMutation) AddedWidth() (r int32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *ImageMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *ImageMutation) SetHeight(i int32) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *ImageMutation) Height() (r int32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *ImageMutation) AddHeight(i int32) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *ImageMutation) AddedHeight() (r int32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *ImageMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetExif sets the "exif" field.
func (m *ImageMutation) SetExif(jm json.RawMessage) {
	m.exif = &jm
	m.appendexif = nil
}

// Exif returns the value of the "exif" field in the mutation.
func (m *ImageMutation) Exif() (r json.RawMessage, exists bool) {
	v := m.exif
	if v == nil {
		return
	}
	return *v, true
}

// OldExif returns the old "exif" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldExif(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExif is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExif requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExif: %w", err)
	}
	return oldValue.Exif, nil
}

// AppendExif adds jm to the "exif" field.
func (m *ImageMutation) AppendExif(jm json.RawMessage) {
	m.appendexif = append(m.appendexif, jm...)
}

// AppendedExif returns the list of values that were appended to the "exif" field in this mutation.
func (m *ImageMutation) AppendedExif() (json.RawMessage, bool) {
	if len(m.appendexif) == 0 {
		return nil, false
	}
	return m.appendexif, true
}

// ResetExif resets all changes to the "exif" field.
func (m *ImageMutation) ResetExif() {
	m.exif = nil
	m.appendexif = nil
}

// SetHash sets the "hash" field.
func (m *ImageMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *ImageMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *ImageMutation) ResetHash() {
	m.hash = nil
}

// SetAddress sets the "address" field.
func (m *ImageMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ImageMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *ImageMutation) ResetAddress() {
	m.address = nil
}

// SetIsPublic sets the "isPublic" field.
func (m *ImageMutation) SetIsPublic(b bool) {
	m.isPublic = &b
}

// IsPublic returns the value of the "isPublic" field in the mutation.
func (m *ImageMutation) IsPublic() (r bool, exists bool) {
	v := m.isPublic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "isPublic" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "isPublic" field.
func (m *ImageMutation) ResetIsPublic() {
	m.isPublic = nil
}

// SetDescription sets the "description" field.
func (m *ImageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImageMutation) ResetDescription() {
	m.description = nil
}

// SetTags sets the "tags" field.
func (m *ImageMutation) SetTags(jm json.RawMessage) {
	m.tags = &jm
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ImageMutation) Tags() (r json.RawMessage, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldTags(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds jm to the "tags" field.
func (m *ImageMutation) AppendTags(jm json.RawMessage) {
	m.appendtags = append(m.appendtags, jm...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ImageMutation) AppendedTags() (json.RawMessage, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *ImageMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetThumbnail10x sets the "thumbnail_10x" field.
func (m *ImageMutation) SetThumbnail10x(b []byte) {
	m.thumbnail_10x = &b
}

// Thumbnail10x returns the value of the "thumbnail_10x" field in the mutation.
func (m *ImageMutation) Thumbnail10x() (r []byte, exists bool) {
	v := m.thumbnail_10x
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail10x returns the old "thumbnail_10x" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldThumbnail10x(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail10x is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail10x requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail10x: %w", err)
	}
	return oldValue.Thumbnail10x, nil
}

// ResetThumbnail10x resets all changes to the "thumbnail_10x" field.
func (m *ImageMutation) ResetThumbnail10x() {
	m.thumbnail_10x = nil
}

// SetThumbnail320xID sets the "thumbnail_320x_id" field.
func (m *ImageMutation) SetThumbnail320xID(s string) {
	m.thumbnail320x = &s
}

// Thumbnail320xID returns the value of the "thumbnail_320x_id" field in the mutation.
func (m *ImageMutation) Thumbnail320xID() (r string, exists bool) {
	v := m.thumbnail320x
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail320xID returns the old "thumbnail_320x_id" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldThumbnail320xID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail320xID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail320xID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail320xID: %w", err)
	}
	return oldValue.Thumbnail320xID, nil
}

// ClearThumbnail320xID clears the value of the "thumbnail_320x_id" field.
func (m *ImageMutation) ClearThumbnail320xID() {
	m.thumbnail320x = nil
	m.clearedFields[image.FieldThumbnail320xID] = struct{}{}
}

// Thumbnail320xIDCleared returns if the "thumbnail_320x_id" field was cleared in this mutation.
func (m *ImageMutation) Thumbnail320xIDCleared() bool {
	_, ok := m.clearedFields[image.FieldThumbnail320xID]
	return ok
}

// ResetThumbnail320xID resets all changes to the "thumbnail_320x_id" field.
func (m *ImageMutation) ResetThumbnail320xID() {
	m.thumbnail320x = nil
	delete(m.clearedFields, image.FieldThumbnail320xID)
}

// SetThumbnail768xID sets the "thumbnail_768x_id" field.
func (m *ImageMutation) SetThumbnail768xID(s string) {
	m.thumbnail768x = &s
}

// Thumbnail768xID returns the value of the "thumbnail_768x_id" field in the mutation.
func (m *ImageMutation) Thumbnail768xID() (r string, exists bool) {
	v := m.thumbnail768x
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail768xID returns the old "thumbnail_768x_id" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldThumbnail768xID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail768xID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail768xID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail768xID: %w", err)
	}
	return oldValue.Thumbnail768xID, nil
}

// ClearThumbnail768xID clears the value of the "thumbnail_768x_id" field.
func (m *ImageMutation) ClearThumbnail768xID() {
	m.thumbnail768x = nil
	m.clearedFields[image.FieldThumbnail768xID] = struct{}{}
}

// Thumbnail768xIDCleared returns if the "thumbnail_768x_id" field was cleared in this mutation.
func (m *ImageMutation) Thumbnail768xIDCleared() bool {
	_, ok := m.clearedFields[image.FieldThumbnail768xID]
	return ok
}

// ResetThumbnail768xID resets all changes to the "thumbnail_768x_id" field.
func (m *ImageMutation) ResetThumbnail768xID() {
	m.thumbnail768x = nil
	delete(m.clearedFields, image.FieldThumbnail768xID)
}

// SetCompressedID sets the "compressed_id" field.
func (m *ImageMutation) SetCompressedID(s string) {
	m.compressed = &s
}

// CompressedID returns the value of the "compressed_id" field in the mutation.
func (m *ImageMutation) CompressedID() (r string, exists bool) {
	v := m.compressed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompressedID returns the old "compressed_id" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCompressedID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompressedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompressedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompressedID: %w", err)
	}
	return oldValue.CompressedID, nil
}

// ClearCompressedID clears the value of the "compressed_id" field.
func (m *ImageMutation) ClearCompressedID() {
	m.compressed = nil
	m.clearedFields[image.FieldCompressedID] = struct{}{}
}

// CompressedIDCleared returns if the "compressed_id" field was cleared in this mutation.
func (m *ImageMutation) CompressedIDCleared() bool {
	_, ok := m.clearedFields[image.FieldCompressedID]
	return ok
}

// ResetCompressedID resets all changes to the "compressed_id" field.
func (m *ImageMutation) ResetCompressedID() {
	m.compressed = nil
	delete(m.clearedFields, image.FieldCompressedID)
}

// SetOriginalID sets the "original_id" field.
func (m *ImageMutation) SetOriginalID(s string) {
	m.original = &s
}

// OriginalID returns the value of the "original_id" field in the mutation.
func (m *ImageMutation) OriginalID() (r string, exists bool) {
	v := m.original
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalID returns the old "original_id" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldOriginalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalID: %w", err)
	}
	return oldValue.OriginalID, nil
}

// ClearOriginalID clears the value of the "original_id" field.
func (m *ImageMutation) ClearOriginalID() {
	m.original = nil
	m.clearedFields[image.FieldOriginalID] = struct{}{}
}

// OriginalIDCleared returns if the "original_id" field was cleared in this mutation.
func (m *ImageMutation) OriginalIDCleared() bool {
	_, ok := m.clearedFields[image.FieldOriginalID]
	return ok
}

// ResetOriginalID resets all changes to the "original_id" field.
func (m *ImageMutation) ResetOriginalID() {
	m.original = nil
	delete(m.clearedFields, image.FieldOriginalID)
}

// SetCreatedAt sets the "createdAt" field.
func (m *ImageMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ImageMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ImageMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ImageMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetUploadedBy sets the "uploadedBy" field.
func (m *ImageMutation) SetUploadedBy(s string) {
	m.user = &s
}

// UploadedBy returns the value of the "uploadedBy" field in the mutation.
func (m *ImageMutation) UploadedBy() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedBy returns the old "uploadedBy" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUploadedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedBy: %w", err)
	}
	return oldValue.UploadedBy, nil
}

// ClearUploadedBy clears the value of the "uploadedBy" field.
func (m *ImageMutation) ClearUploadedBy() {
	m.user = nil
	m.clearedFields[image.FieldUploadedBy] = struct{}{}
}

// UploadedByCleared returns if the "uploadedBy" field was cleared in this mutation.
func (m *ImageMutation) UploadedByCleared() bool {
	_, ok := m.clearedFields[image.FieldUploadedBy]
	return ok
}

// ResetUploadedBy resets all changes to the "uploadedBy" field.
func (m *ImageMutation) ResetUploadedBy() {
	m.user = nil
	delete(m.clearedFields, image.FieldUploadedBy)
}

// SetCategory sets the "category" field.
func (m *ImageMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ImageMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ImageMutation) ResetCategory() {
	m.category = nil
}

// SetExtraData sets the "extraData" field.
func (m *ImageMutation) SetExtraData(jm json.RawMessage) {
	m.extraData = &jm
	m.appendextraData = nil
}

// ExtraData returns the value of the "extraData" field in the mutation.
func (m *ImageMutation) ExtraData() (r json.RawMessage, exists bool) {
	v := m.extraData
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extraData" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldExtraData(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// AppendExtraData adds jm to the "extraData" field.
func (m *ImageMutation) AppendExtraData(jm json.RawMessage) {
	m.appendextraData = append(m.appendextraData, jm...)
}

// AppendedExtraData returns the list of values that were appended to the "extraData" field in this mutation.
func (m *ImageMutation) AppendedExtraData() (json.RawMessage, bool) {
	if len(m.appendextraData) == 0 {
		return nil, false
	}
	return m.appendextraData, true
}

// ResetExtraData resets all changes to the "extraData" field.
func (m *ImageMutation) ResetExtraData() {
	m.extraData = nil
	m.appendextraData = nil
}

// SetDescriptionVector sets the "description_vector" field.
func (m *ImageMutation) SetDescriptionVector(jm json.RawMessage) {
	m.description_vector = &jm
	m.appenddescription_vector = nil
}

// DescriptionVector returns the value of the "description_vector" field in the mutation.
func (m *ImageMutation) DescriptionVector() (r json.RawMessage, exists bool) {
	v := m.description_vector
	if v == nil {
		return
	}
	return *v, true
}

// OldDescriptionVector returns the old "description_vector" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldDescriptionVector(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescriptionVector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescriptionVector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescriptionVector: %w", err)
	}
	return oldValue.DescriptionVector, nil
}

// AppendDescriptionVector adds jm to the "description_vector" field.
func (m *ImageMutation) AppendDescriptionVector(jm json.RawMessage) {
	m.appenddescription_vector = append(m.appenddescription_vector, jm...)
}

// AppendedDescriptionVector returns the list of values that were appended to the "description_vector" field in this mutation.
func (m *ImageMutation) AppendedDescriptionVector() (json.RawMessage, bool) {
	if len(m.appenddescription_vector) == 0 {
		return nil, false
	}
	return m.appenddescription_vector, true
}

// ClearDescriptionVector clears the value of the "description_vector" field.
func (m *ImageMutation) ClearDescriptionVector() {
	m.description_vector = nil
	m.appenddescription_vector = nil
	m.clearedFields[image.FieldDescriptionVector] = struct{}{}
}

// DescriptionVectorCleared returns if the "description_vector" field was cleared in this mutation.
func (m *ImageMutation) DescriptionVectorCleared() bool {
	_, ok := m.clearedFields[image.FieldDescriptionVector]
	return ok
}

// ResetDescriptionVector resets all changes to the "description_vector" field.
func (m *ImageMutation) ResetDescriptionVector() {
	m.description_vector = nil
	m.appenddescription_vector = nil
	delete(m.clearedFields, image.FieldDescriptionVector)
}

// ClearCompressed clears the "compressed" edge to the File entity.
func (m *ImageMutation) ClearCompressed() {
	m.clearedcompressed = true
	m.clearedFields[image.FieldCompressedID] = struct{}{}
}

// CompressedCleared reports if the "compressed" edge to the File entity was cleared.
func (m *ImageMutation) CompressedCleared() bool {
	return m.CompressedIDCleared() || m.clearedcompressed
}

// CompressedIDs returns the "compressed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompressedID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) CompressedIDs() (ids []string) {
	if id := m.compressed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompressed resets all changes to the "compressed" edge.
func (m *ImageMutation) ResetCompressed() {
	m.compressed = nil
	m.clearedcompressed = false
}

// ClearOriginal clears the "original" edge to the File entity.
func (m *ImageMutation) ClearOriginal() {
	m.clearedoriginal = true
	m.clearedFields[image.FieldOriginalID] = struct{}{}
}

// OriginalCleared reports if the "original" edge to the File entity was cleared.
func (m *ImageMutation) OriginalCleared() bool {
	return m.OriginalIDCleared() || m.clearedoriginal
}

// OriginalIDs returns the "original" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OriginalID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) OriginalIDs() (ids []string) {
	if id := m.original; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOriginal resets all changes to the "original" edge.
func (m *ImageMutation) ResetOriginal() {
	m.original = nil
	m.clearedoriginal = false
}

// ClearThumbnail320x clears the "thumbnail320x" edge to the File entity.
func (m *ImageMutation) ClearThumbnail320x() {
	m.clearedthumbnail320x = true
	m.clearedFields[image.FieldThumbnail320xID] = struct{}{}
}

// Thumbnail320xCleared reports if the "thumbnail320x" edge to the File entity was cleared.
func (m *ImageMutation) Thumbnail320xCleared() bool {
	return m.Thumbnail320xIDCleared() || m.clearedthumbnail320x
}

// Thumbnail320xIDs returns the "thumbnail320x" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// Thumbnail320xID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) Thumbnail320xIDs() (ids []string) {
	if id := m.thumbnail320x; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThumbnail320x resets all changes to the "thumbnail320x" edge.
func (m *ImageMutation) ResetThumbnail320x() {
	m.thumbnail320x = nil
	m.clearedthumbnail320x = false
}

// ClearThumbnail768x clears the "thumbnail768x" edge to the File entity.
func (m *ImageMutation) ClearThumbnail768x() {
	m.clearedthumbnail768x = true
	m.clearedFields[image.FieldThumbnail768xID] = struct{}{}
}

// Thumbnail768xCleared reports if the "thumbnail768x" edge to the File entity was cleared.
func (m *ImageMutation) Thumbnail768xCleared() bool {
	return m.Thumbnail768xIDCleared() || m.clearedthumbnail768x
}

// Thumbnail768xIDs returns the "thumbnail768x" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// Thumbnail768xID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) Thumbnail768xIDs() (ids []string) {
	if id := m.thumbnail768x; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThumbnail768x resets all changes to the "thumbnail768x" edge.
func (m *ImageMutation) ResetThumbnail768x() {
	m.thumbnail768x = nil
	m.clearedthumbnail768x = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ImageMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ImageMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[image.FieldUploadedBy] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ImageMutation) UserCleared() bool {
	return m.UploadedByCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ImageMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ImageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMomentImageIDs adds the "moment_images" edge to the MomentImage entity by ids.
func (m *ImageMutation) AddMomentImageIDs(ids ...uint) {
	if m.moment_images == nil {
		m.moment_images = make(map[uint]struct{})
	}
	for i := range ids {
		m.moment_images[ids[i]] = struct{}{}
	}
}

// ClearMomentImages clears the "moment_images" edge to the MomentImage entity.
func (m *ImageMutation) ClearMomentImages() {
	m.clearedmoment_images = true
}

// MomentImagesCleared reports if the "moment_images" edge to the MomentImage entity was cleared.
func (m *ImageMutation) MomentImagesCleared() bool {
	return m.clearedmoment_images
}

// RemoveMomentImageIDs removes the "moment_images" edge to the MomentImage entity by IDs.
func (m *ImageMutation) RemoveMomentImageIDs(ids ...uint) {
	if m.removedmoment_images == nil {
		m.removedmoment_images = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.moment_images, ids[i])
		m.removedmoment_images[ids[i]] = struct{}{}
	}
}

// RemovedMomentImages returns the removed IDs of the "moment_images" edge to the MomentImage entity.
func (m *ImageMutation) RemovedMomentImagesIDs() (ids []uint) {
	for id := range m.removedmoment_images {
		ids = append(ids, id)
	}
	return
}

// MomentImagesIDs returns the "moment_images" edge IDs in the mutation.
func (m *ImageMutation) MomentImagesIDs() (ids []uint) {
	for id := range m.moment_images {
		ids = append(ids, id)
	}
	return
}

// ResetMomentImages resets all changes to the "moment_images" edge.
func (m *ImageMutation) ResetMomentImages() {
	m.moment_images = nil
	m.clearedmoment_images = false
	m.removedmoment_images = nil
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.name != nil {
		fields = append(fields, image.FieldName)
	}
	if m._type != nil {
		fields = append(fields, image.FieldType)
	}
	if m.size != nil {
		fields = append(fields, image.FieldSize)
	}
	if m.width != nil {
		fields = append(fields, image.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, image.FieldHeight)
	}
	if m.exif != nil {
		fields = append(fields, image.FieldExif)
	}
	if m.hash != nil {
		fields = append(fields, image.FieldHash)
	}
	if m.address != nil {
		fields = append(fields, image.FieldAddress)
	}
	if m.isPublic != nil {
		fields = append(fields, image.FieldIsPublic)
	}
	if m.description != nil {
		fields = append(fields, image.FieldDescription)
	}
	if m.tags != nil {
		fields = append(fields, image.FieldTags)
	}
	if m.thumbnail_10x != nil {
		fields = append(fields, image.FieldThumbnail10x)
	}
	if m.thumbnail320x != nil {
		fields = append(fields, image.FieldThumbnail320xID)
	}
	if m.thumbnail768x != nil {
		fields = append(fields, image.FieldThumbnail768xID)
	}
	if m.compressed != nil {
		fields = append(fields, image.FieldCompressedID)
	}
	if m.original != nil {
		fields = append(fields, image.FieldOriginalID)
	}
	if m.createdAt != nil {
		fields = append(fields, image.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, image.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, image.FieldUploadedBy)
	}
	if m.category != nil {
		fields = append(fields, image.FieldCategory)
	}
	if m.extraData != nil {
		fields = append(fields, image.FieldExtraData)
	}
	if m.description_vector != nil {
		fields = append(fields, image.FieldDescriptionVector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldName:
		return m.Name()
	case image.FieldType:
		return m.GetType()
	case image.FieldSize:
		return m.Size()
	case image.FieldWidth:
		return m.Width()
	case image.FieldHeight:
		return m.Height()
	case image.FieldExif:
		return m.Exif()
	case image.FieldHash:
		return m.Hash()
	case image.FieldAddress:
		return m.Address()
	case image.FieldIsPublic:
		return m.IsPublic()
	case image.FieldDescription:
		return m.Description()
	case image.FieldTags:
		return m.Tags()
	case image.FieldThumbnail10x:
		return m.Thumbnail10x()
	case image.FieldThumbnail320xID:
		return m.Thumbnail320xID()
	case image.FieldThumbnail768xID:
		return m.Thumbnail768xID()
	case image.FieldCompressedID:
		return m.CompressedID()
	case image.FieldOriginalID:
		return m.OriginalID()
	case image.FieldCreatedAt:
		return m.CreatedAt()
	case image.FieldUpdatedAt:
		return m.UpdatedAt()
	case image.FieldUploadedBy:
		return m.UploadedBy()
	case image.FieldCategory:
		return m.Category()
	case image.FieldExtraData:
		return m.ExtraData()
	case image.FieldDescriptionVector:
		return m.DescriptionVector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldName:
		return m.OldName(ctx)
	case image.FieldType:
		return m.OldType(ctx)
	case image.FieldSize:
		return m.OldSize(ctx)
	case image.FieldWidth:
		return m.OldWidth(ctx)
	case image.FieldHeight:
		return m.OldHeight(ctx)
	case image.FieldExif:
		return m.OldExif(ctx)
	case image.FieldHash:
		return m.OldHash(ctx)
	case image.FieldAddress:
		return m.OldAddress(ctx)
	case image.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case image.FieldDescription:
		return m.OldDescription(ctx)
	case image.FieldTags:
		return m.OldTags(ctx)
	case image.FieldThumbnail10x:
		return m.OldThumbnail10x(ctx)
	case image.FieldThumbnail320xID:
		return m.OldThumbnail320xID(ctx)
	case image.FieldThumbnail768xID:
		return m.OldThumbnail768xID(ctx)
	case image.FieldCompressedID:
		return m.OldCompressedID(ctx)
	case image.FieldOriginalID:
		return m.OldOriginalID(ctx)
	case image.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case image.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case image.FieldUploadedBy:
		return m.OldUploadedBy(ctx)
	case image.FieldCategory:
		return m.OldCategory(ctx)
	case image.FieldExtraData:
		return m.OldExtraData(ctx)
	case image.FieldDescriptionVector:
		return m.OldDescriptionVector(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case image.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case image.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case image.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case image.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case image.FieldExif:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExif(v)
		return nil
	case image.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case image.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case image.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case image.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case image.FieldTags:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case image.FieldThumbnail10x:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail10x(v)
		return nil
	case image.FieldThumbnail320xID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail320xID(v)
		return nil
	case image.FieldThumbnail768xID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail768xID(v)
		return nil
	case image.FieldCompressedID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompressedID(v)
		return nil
	case image.FieldOriginalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalID(v)
		return nil
	case image.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case image.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case image.FieldUploadedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedBy(v)
		return nil
	case image.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case image.FieldExtraData:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case image.FieldDescriptionVector:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescriptionVector(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, image.FieldSize)
	}
	if m.addwidth != nil {
		fields = append(fields, image.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, image.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case image.FieldSize:
		return m.AddedSize()
	case image.FieldWidth:
		return m.AddedWidth()
	case image.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case image.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case image.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case image.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(image.FieldThumbnail320xID) {
		fields = append(fields, image.FieldThumbnail320xID)
	}
	if m.FieldCleared(image.FieldThumbnail768xID) {
		fields = append(fields, image.FieldThumbnail768xID)
	}
	if m.FieldCleared(image.FieldCompressedID) {
		fields = append(fields, image.FieldCompressedID)
	}
	if m.FieldCleared(image.FieldOriginalID) {
		fields = append(fields, image.FieldOriginalID)
	}
	if m.FieldCleared(image.FieldUploadedBy) {
		fields = append(fields, image.FieldUploadedBy)
	}
	if m.FieldCleared(image.FieldDescriptionVector) {
		fields = append(fields, image.FieldDescriptionVector)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	switch name {
	case image.FieldThumbnail320xID:
		m.ClearThumbnail320xID()
		return nil
	case image.FieldThumbnail768xID:
		m.ClearThumbnail768xID()
		return nil
	case image.FieldCompressedID:
		m.ClearCompressedID()
		return nil
	case image.FieldOriginalID:
		m.ClearOriginalID()
		return nil
	case image.FieldUploadedBy:
		m.ClearUploadedBy()
		return nil
	case image.FieldDescriptionVector:
		m.ClearDescriptionVector()
		return nil
	}
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldName:
		m.ResetName()
		return nil
	case image.FieldType:
		m.ResetType()
		return nil
	case image.FieldSize:
		m.ResetSize()
		return nil
	case image.FieldWidth:
		m.ResetWidth()
		return nil
	case image.FieldHeight:
		m.ResetHeight()
		return nil
	case image.FieldExif:
		m.ResetExif()
		return nil
	case image.FieldHash:
		m.ResetHash()
		return nil
	case image.FieldAddress:
		m.ResetAddress()
		return nil
	case image.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case image.FieldDescription:
		m.ResetDescription()
		return nil
	case image.FieldTags:
		m.ResetTags()
		return nil
	case image.FieldThumbnail10x:
		m.ResetThumbnail10x()
		return nil
	case image.FieldThumbnail320xID:
		m.ResetThumbnail320xID()
		return nil
	case image.FieldThumbnail768xID:
		m.ResetThumbnail768xID()
		return nil
	case image.FieldCompressedID:
		m.ResetCompressedID()
		return nil
	case image.FieldOriginalID:
		m.ResetOriginalID()
		return nil
	case image.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case image.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case image.FieldUploadedBy:
		m.ResetUploadedBy()
		return nil
	case image.FieldCategory:
		m.ResetCategory()
		return nil
	case image.FieldExtraData:
		m.ResetExtraData()
		return nil
	case image.FieldDescriptionVector:
		m.ResetDescriptionVector()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.compressed != nil {
		edges = append(edges, image.EdgeCompressed)
	}
	if m.original != nil {
		edges = append(edges, image.EdgeOriginal)
	}
	if m.thumbnail320x != nil {
		edges = append(edges, image.EdgeThumbnail320x)
	}
	if m.thumbnail768x != nil {
		edges = append(edges, image.EdgeThumbnail768x)
	}
	if m.user != nil {
		edges = append(edges, image.EdgeUser)
	}
	if m.moment_images != nil {
		edges = append(edges, image.EdgeMomentImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeCompressed:
		if id := m.compressed; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeOriginal:
		if id := m.original; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeThumbnail320x:
		if id := m.thumbnail320x; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeThumbnail768x:
		if id := m.thumbnail768x; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeMomentImages:
		ids := make([]ent.Value, 0, len(m.moment_images))
		for id := range m.moment_images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmoment_images != nil {
		edges = append(edges, image.EdgeMomentImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeMomentImages:
		ids := make([]ent.Value, 0, len(m.removedmoment_images))
		for id := range m.removedmoment_images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcompressed {
		edges = append(edges, image.EdgeCompressed)
	}
	if m.clearedoriginal {
		edges = append(edges, image.EdgeOriginal)
	}
	if m.clearedthumbnail320x {
		edges = append(edges, image.EdgeThumbnail320x)
	}
	if m.clearedthumbnail768x {
		edges = append(edges, image.EdgeThumbnail768x)
	}
	if m.cleareduser {
		edges = append(edges, image.EdgeUser)
	}
	if m.clearedmoment_images {
		edges = append(edges, image.EdgeMomentImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeCompressed:
		return m.clearedcompressed
	case image.EdgeOriginal:
		return m.clearedoriginal
	case image.EdgeThumbnail320x:
		return m.clearedthumbnail320x
	case image.EdgeThumbnail768x:
		return m.clearedthumbnail768x
	case image.EdgeUser:
		return m.cleareduser
	case image.EdgeMomentImages:
		return m.clearedmoment_images
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeCompressed:
		m.ClearCompressed()
		return nil
	case image.EdgeOriginal:
		m.ClearOriginal()
		return nil
	case image.EdgeThumbnail320x:
		m.ClearThumbnail320x()
		return nil
	case image.EdgeThumbnail768x:
		m.ClearThumbnail768x()
		return nil
	case image.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeCompressed:
		m.ResetCompressed()
		return nil
	case image.EdgeOriginal:
		m.ResetOriginal()
		return nil
	case image.EdgeThumbnail320x:
		m.ResetThumbnail320x()
		return nil
	case image.EdgeThumbnail768x:
		m.ResetThumbnail768x()
		return nil
	case image.EdgeUser:
		m.ResetUser()
		return nil
	case image.EdgeMomentImages:
		m.ResetMomentImages()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// KeepMutation represents an operation that mutates the Keep nodes in the graph.
type KeepMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	title                *string
	content              *string
	isPublic             *bool
	tags                 *json.RawMessage
	appendtags           json.RawMessage
	createdAt            *time.Time
	updatedAt            *time.Time
	category             *string
	views                *int32
	addviews             *int32
	likes                *int32
	addlikes             *int32
	summary              *string
	extraData            *json.RawMessage
	appendextraData      json.RawMessage
	content_vector       *json.RawMessage
	appendcontent_vector json.RawMessage
	summary_vector       *json.RawMessage
	appendsummary_vector json.RawMessage
	title_vector         *json.RawMessage
	appendtitle_vector   json.RawMessage
	clearedFields        map[string]struct{}
	user                 *string
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Keep, error)
	predicates           []predicate.Keep
}

var _ ent.Mutation = (*KeepMutation)(nil)

// keepOption allows management of the mutation configuration using functional options.
type keepOption func(*KeepMutation)

// newKeepMutation creates new mutation for the Keep entity.
func newKeepMutation(c config, op Op, opts ...keepOption) *KeepMutation {
	m := &KeepMutation{
		config:        c,
		op:            op,
		typ:           TypeKeep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeepID sets the ID field of the mutation.
func withKeepID(id string) keepOption {
	return func(m *KeepMutation) {
		var (
			err   error
			once  sync.Once
			value *Keep
		)
		m.oldValue = func(ctx context.Context) (*Keep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Keep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeep sets the old Keep of the mutation.
func withKeep(node *Keep) keepOption {
	return func(m *KeepMutation) {
		m.oldValue = func(context.Context) (*Keep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Keep entities.
func (m *KeepMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeepMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeepMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Keep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *KeepMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *KeepMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *KeepMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *KeepMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *KeepMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *KeepMutation) ResetContent() {
	m.content = nil
}

// SetIsPublic sets the "isPublic" field.
func (m *KeepMutation) SetIsPublic(b bool) {
	m.isPublic = &b
}

// IsPublic returns the value of the "isPublic" field in the mutation.
func (m *KeepMutation) IsPublic() (r bool, exists bool) {
	v := m.isPublic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "isPublic" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "isPublic" field.
func (m *KeepMutation) ResetIsPublic() {
	m.isPublic = nil
}

// SetTags sets the "tags" field.
func (m *KeepMutation) SetTags(jm json.RawMessage) {
	m.tags = &jm
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *KeepMutation) Tags() (r json.RawMessage, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldTags(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds jm to the "tags" field.
func (m *KeepMutation) AppendTags(jm json.RawMessage) {
	m.appendtags = append(m.appendtags, jm...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *KeepMutation) AppendedTags() (json.RawMessage, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *KeepMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *KeepMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *KeepMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *KeepMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *KeepMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *KeepMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *KeepMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetOwnerId sets the "ownerId" field.
func (m *KeepMutation) SetOwnerId(s string) {
	m.user = &s
}

// OwnerId returns the value of the "ownerId" field in the mutation.
func (m *KeepMutation) OwnerId() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerId returns the old "ownerId" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldOwnerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerId: %w", err)
	}
	return oldValue.OwnerId, nil
}

// ClearOwnerId clears the value of the "ownerId" field.
func (m *KeepMutation) ClearOwnerId() {
	m.user = nil
	m.clearedFields[keep.FieldOwnerId] = struct{}{}
}

// OwnerIdCleared returns if the "ownerId" field was cleared in this mutation.
func (m *KeepMutation) OwnerIdCleared() bool {
	_, ok := m.clearedFields[keep.FieldOwnerId]
	return ok
}

// ResetOwnerId resets all changes to the "ownerId" field.
func (m *KeepMutation) ResetOwnerId() {
	m.user = nil
	delete(m.clearedFields, keep.FieldOwnerId)
}

// SetCategory sets the "category" field.
func (m *KeepMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *KeepMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *KeepMutation) ResetCategory() {
	m.category = nil
}

// SetViews sets the "views" field.
func (m *KeepMutation) SetViews(i int32) {
	m.views = &i
	m.addviews = nil
}

// Views returns the value of the "views" field in the mutation.
func (m *KeepMutation) Views() (r int32, exists bool) {
	v := m.views
	if v == nil {
		return
	}
	return *v, true
}

// OldViews returns the old "views" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldViews(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViews: %w", err)
	}
	return oldValue.Views, nil
}

// AddViews adds i to the "views" field.
func (m *KeepMutation) AddViews(i int32) {
	if m.addviews != nil {
		*m.addviews += i
	} else {
		m.addviews = &i
	}
}

// AddedViews returns the value that was added to the "views" field in this mutation.
func (m *KeepMutation) AddedViews() (r int32, exists bool) {
	v := m.addviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetViews resets all changes to the "views" field.
func (m *KeepMutation) ResetViews() {
	m.views = nil
	m.addviews = nil
}

// SetLikes sets the "likes" field.
func (m *KeepMutation) SetLikes(i int32) {
	m.likes = &i
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *KeepMutation) Likes() (r int32, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldLikes(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds i to the "likes" field.
func (m *KeepMutation) AddLikes(i int32) {
	if m.addlikes != nil {
		*m.addlikes += i
	} else {
		m.addlikes = &i
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *KeepMutation) AddedLikes() (r int32, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikes resets all changes to the "likes" field.
func (m *KeepMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
}

// SetSummary sets the "summary" field.
func (m *KeepMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *KeepMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *KeepMutation) ResetSummary() {
	m.summary = nil
}

// SetExtraData sets the "extraData" field.
func (m *KeepMutation) SetExtraData(jm json.RawMessage) {
	m.extraData = &jm
	m.appendextraData = nil
}

// ExtraData returns the value of the "extraData" field in the mutation.
func (m *KeepMutation) ExtraData() (r json.RawMessage, exists bool) {
	v := m.extraData
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extraData" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldExtraData(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// AppendExtraData adds jm to the "extraData" field.
func (m *KeepMutation) AppendExtraData(jm json.RawMessage) {
	m.appendextraData = append(m.appendextraData, jm...)
}

// AppendedExtraData returns the list of values that were appended to the "extraData" field in this mutation.
func (m *KeepMutation) AppendedExtraData() (json.RawMessage, bool) {
	if len(m.appendextraData) == 0 {
		return nil, false
	}
	return m.appendextraData, true
}

// ResetExtraData resets all changes to the "extraData" field.
func (m *KeepMutation) ResetExtraData() {
	m.extraData = nil
	m.appendextraData = nil
}

// SetContentVector sets the "content_vector" field.
func (m *KeepMutation) SetContentVector(jm json.RawMessage) {
	m.content_vector = &jm
	m.appendcontent_vector = nil
}

// ContentVector returns the value of the "content_vector" field in the mutation.
func (m *KeepMutation) ContentVector() (r json.RawMessage, exists bool) {
	v := m.content_vector
	if v == nil {
		return
	}
	return *v, true
}

// OldContentVector returns the old "content_vector" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldContentVector(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentVector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentVector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentVector: %w", err)
	}
	return oldValue.ContentVector, nil
}

// AppendContentVector adds jm to the "content_vector" field.
func (m *KeepMutation) AppendContentVector(jm json.RawMessage) {
	m.appendcontent_vector = append(m.appendcontent_vector, jm...)
}

// AppendedContentVector returns the list of values that were appended to the "content_vector" field in this mutation.
func (m *KeepMutation) AppendedContentVector() (json.RawMessage, bool) {
	if len(m.appendcontent_vector) == 0 {
		return nil, false
	}
	return m.appendcontent_vector, true
}

// ClearContentVector clears the value of the "content_vector" field.
func (m *KeepMutation) ClearContentVector() {
	m.content_vector = nil
	m.appendcontent_vector = nil
	m.clearedFields[keep.FieldContentVector] = struct{}{}
}

// ContentVectorCleared returns if the "content_vector" field was cleared in this mutation.
func (m *KeepMutation) ContentVectorCleared() bool {
	_, ok := m.clearedFields[keep.FieldContentVector]
	return ok
}

// ResetContentVector resets all changes to the "content_vector" field.
func (m *KeepMutation) ResetContentVector() {
	m.content_vector = nil
	m.appendcontent_vector = nil
	delete(m.clearedFields, keep.FieldContentVector)
}

// SetSummaryVector sets the "summary_vector" field.
func (m *KeepMutation) SetSummaryVector(jm json.RawMessage) {
	m.summary_vector = &jm
	m.appendsummary_vector = nil
}

// SummaryVector returns the value of the "summary_vector" field in the mutation.
func (m *KeepMutation) SummaryVector() (r json.RawMessage, exists bool) {
	v := m.summary_vector
	if v == nil {
		return
	}
	return *v, true
}

// OldSummaryVector returns the old "summary_vector" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldSummaryVector(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummaryVector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummaryVector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummaryVector: %w", err)
	}
	return oldValue.SummaryVector, nil
}

// AppendSummaryVector adds jm to the "summary_vector" field.
func (m *KeepMutation) AppendSummaryVector(jm json.RawMessage) {
	m.appendsummary_vector = append(m.appendsummary_vector, jm...)
}

// AppendedSummaryVector returns the list of values that were appended to the "summary_vector" field in this mutation.
func (m *KeepMutation) AppendedSummaryVector() (json.RawMessage, bool) {
	if len(m.appendsummary_vector) == 0 {
		return nil, false
	}
	return m.appendsummary_vector, true
}

// ClearSummaryVector clears the value of the "summary_vector" field.
func (m *KeepMutation) ClearSummaryVector() {
	m.summary_vector = nil
	m.appendsummary_vector = nil
	m.clearedFields[keep.FieldSummaryVector] = struct{}{}
}

// SummaryVectorCleared returns if the "summary_vector" field was cleared in this mutation.
func (m *KeepMutation) SummaryVectorCleared() bool {
	_, ok := m.clearedFields[keep.FieldSummaryVector]
	return ok
}

// ResetSummaryVector resets all changes to the "summary_vector" field.
func (m *KeepMutation) ResetSummaryVector() {
	m.summary_vector = nil
	m.appendsummary_vector = nil
	delete(m.clearedFields, keep.FieldSummaryVector)
}

// SetTitleVector sets the "title_vector" field.
func (m *KeepMutation) SetTitleVector(jm json.RawMessage) {
	m.title_vector = &jm
	m.appendtitle_vector = nil
}

// TitleVector returns the value of the "title_vector" field in the mutation.
func (m *KeepMutation) TitleVector() (r json.RawMessage, exists bool) {
	v := m.title_vector
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleVector returns the old "title_vector" field's value of the Keep entity.
// If the Keep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeepMutation) OldTitleVector(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitleVector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitleVector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleVector: %w", err)
	}
	return oldValue.TitleVector, nil
}

// AppendTitleVector adds jm to the "title_vector" field.
func (m *KeepMutation) AppendTitleVector(jm json.RawMessage) {
	m.appendtitle_vector = append(m.appendtitle_vector, jm...)
}

// AppendedTitleVector returns the list of values that were appended to the "title_vector" field in this mutation.
func (m *KeepMutation) AppendedTitleVector() (json.RawMessage, bool) {
	if len(m.appendtitle_vector) == 0 {
		return nil, false
	}
	return m.appendtitle_vector, true
}

// ClearTitleVector clears the value of the "title_vector" field.
func (m *KeepMutation) ClearTitleVector() {
	m.title_vector = nil
	m.appendtitle_vector = nil
	m.clearedFields[keep.FieldTitleVector] = struct{}{}
}

// TitleVectorCleared returns if the "title_vector" field was cleared in this mutation.
func (m *KeepMutation) TitleVectorCleared() bool {
	_, ok := m.clearedFields[keep.FieldTitleVector]
	return ok
}

// ResetTitleVector resets all changes to the "title_vector" field.
func (m *KeepMutation) ResetTitleVector() {
	m.title_vector = nil
	m.appendtitle_vector = nil
	delete(m.clearedFields, keep.FieldTitleVector)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *KeepMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *KeepMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[keep.FieldOwnerId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *KeepMutation) UserCleared() bool {
	return m.OwnerIdCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *KeepMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *KeepMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *KeepMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the KeepMutation builder.
func (m *KeepMutation) Where(ps ...predicate.Keep) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KeepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KeepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Keep, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KeepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KeepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Keep).
func (m *KeepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeepMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.title != nil {
		fields = append(fields, keep.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, keep.FieldContent)
	}
	if m.isPublic != nil {
		fields = append(fields, keep.FieldIsPublic)
	}
	if m.tags != nil {
		fields = append(fields, keep.FieldTags)
	}
	if m.createdAt != nil {
		fields = append(fields, keep.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, keep.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, keep.FieldOwnerId)
	}
	if m.category != nil {
		fields = append(fields, keep.FieldCategory)
	}
	if m.views != nil {
		fields = append(fields, keep.FieldViews)
	}
	if m.likes != nil {
		fields = append(fields, keep.FieldLikes)
	}
	if m.summary != nil {
		fields = append(fields, keep.FieldSummary)
	}
	if m.extraData != nil {
		fields = append(fields, keep.FieldExtraData)
	}
	if m.content_vector != nil {
		fields = append(fields, keep.FieldContentVector)
	}
	if m.summary_vector != nil {
		fields = append(fields, keep.FieldSummaryVector)
	}
	if m.title_vector != nil {
		fields = append(fields, keep.FieldTitleVector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case keep.FieldTitle:
		return m.Title()
	case keep.FieldContent:
		return m.Content()
	case keep.FieldIsPublic:
		return m.IsPublic()
	case keep.FieldTags:
		return m.Tags()
	case keep.FieldCreatedAt:
		return m.CreatedAt()
	case keep.FieldUpdatedAt:
		return m.UpdatedAt()
	case keep.FieldOwnerId:
		return m.OwnerId()
	case keep.FieldCategory:
		return m.Category()
	case keep.FieldViews:
		return m.Views()
	case keep.FieldLikes:
		return m.Likes()
	case keep.FieldSummary:
		return m.Summary()
	case keep.FieldExtraData:
		return m.ExtraData()
	case keep.FieldContentVector:
		return m.ContentVector()
	case keep.FieldSummaryVector:
		return m.SummaryVector()
	case keep.FieldTitleVector:
		return m.TitleVector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case keep.FieldTitle:
		return m.OldTitle(ctx)
	case keep.FieldContent:
		return m.OldContent(ctx)
	case keep.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case keep.FieldTags:
		return m.OldTags(ctx)
	case keep.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case keep.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case keep.FieldOwnerId:
		return m.OldOwnerId(ctx)
	case keep.FieldCategory:
		return m.OldCategory(ctx)
	case keep.FieldViews:
		return m.OldViews(ctx)
	case keep.FieldLikes:
		return m.OldLikes(ctx)
	case keep.FieldSummary:
		return m.OldSummary(ctx)
	case keep.FieldExtraData:
		return m.OldExtraData(ctx)
	case keep.FieldContentVector:
		return m.OldContentVector(ctx)
	case keep.FieldSummaryVector:
		return m.OldSummaryVector(ctx)
	case keep.FieldTitleVector:
		return m.OldTitleVector(ctx)
	}
	return nil, fmt.Errorf("unknown Keep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case keep.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case keep.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case keep.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case keep.FieldTags:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case keep.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case keep.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case keep.FieldOwnerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerId(v)
		return nil
	case keep.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case keep.FieldViews:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViews(v)
		return nil
	case keep.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case keep.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case keep.FieldExtraData:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case keep.FieldContentVector:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentVector(v)
		return nil
	case keep.FieldSummaryVector:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummaryVector(v)
		return nil
	case keep.FieldTitleVector:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleVector(v)
		return nil
	}
	return fmt.Errorf("unknown Keep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeepMutation) AddedFields() []string {
	var fields []string
	if m.addviews != nil {
		fields = append(fields, keep.FieldViews)
	}
	if m.addlikes != nil {
		fields = append(fields, keep.FieldLikes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case keep.FieldViews:
		return m.AddedViews()
	case keep.FieldLikes:
		return m.AddedLikes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case keep.FieldViews:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViews(v)
		return nil
	case keep.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	}
	return fmt.Errorf("unknown Keep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(keep.FieldOwnerId) {
		fields = append(fields, keep.FieldOwnerId)
	}
	if m.FieldCleared(keep.FieldContentVector) {
		fields = append(fields, keep.FieldContentVector)
	}
	if m.FieldCleared(keep.FieldSummaryVector) {
		fields = append(fields, keep.FieldSummaryVector)
	}
	if m.FieldCleared(keep.FieldTitleVector) {
		fields = append(fields, keep.FieldTitleVector)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeepMutation) ClearField(name string) error {
	switch name {
	case keep.FieldOwnerId:
		m.ClearOwnerId()
		return nil
	case keep.FieldContentVector:
		m.ClearContentVector()
		return nil
	case keep.FieldSummaryVector:
		m.ClearSummaryVector()
		return nil
	case keep.FieldTitleVector:
		m.ClearTitleVector()
		return nil
	}
	return fmt.Errorf("unknown Keep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeepMutation) ResetField(name string) error {
	switch name {
	case keep.FieldTitle:
		m.ResetTitle()
		return nil
	case keep.FieldContent:
		m.ResetContent()
		return nil
	case keep.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case keep.FieldTags:
		m.ResetTags()
		return nil
	case keep.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case keep.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case keep.FieldOwnerId:
		m.ResetOwnerId()
		return nil
	case keep.FieldCategory:
		m.ResetCategory()
		return nil
	case keep.FieldViews:
		m.ResetViews()
		return nil
	case keep.FieldLikes:
		m.ResetLikes()
		return nil
	case keep.FieldSummary:
		m.ResetSummary()
		return nil
	case keep.FieldExtraData:
		m.ResetExtraData()
		return nil
	case keep.FieldContentVector:
		m.ResetContentVector()
		return nil
	case keep.FieldSummaryVector:
		m.ResetSummaryVector()
		return nil
	case keep.FieldTitleVector:
		m.ResetTitleVector()
		return nil
	}
	return fmt.Errorf("unknown Keep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeepMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, keep.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case keep.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeepMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, keep.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeepMutation) EdgeCleared(name string) bool {
	switch name {
	case keep.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeepMutation) ClearEdge(name string) error {
	switch name {
	case keep.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Keep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeepMutation) ResetEdge(name string) error {
	switch name {
	case keep.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Keep edge %s", name)
}

// MindmapMutation represents an operation that mutates the Mindmap nodes in the graph.
type MindmapMutation struct {
	config
	op              Op
	typ             string
	id              *string
	title           *string
	content         *json.RawMessage
	appendcontent   json.RawMessage
	isPublic        *bool
	tags            *json.RawMessage
	appendtags      json.RawMessage
	createdAt       *time.Time
	updatedAt       *time.Time
	views           *int32
	addviews        *int32
	likes           *int32
	addlikes        *int32
	summary         *string
	extraData       *json.RawMessage
	appendextraData json.RawMessage
	category        *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Mindmap, error)
	predicates      []predicate.Mindmap
}

var _ ent.Mutation = (*MindmapMutation)(nil)

// mindmapOption allows management of the mutation configuration using functional options.
type mindmapOption func(*MindmapMutation)

// newMindmapMutation creates new mutation for the Mindmap entity.
func newMindmapMutation(c config, op Op, opts ...mindmapOption) *MindmapMutation {
	m := &MindmapMutation{
		config:        c,
		op:            op,
		typ:           TypeMindmap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMindmapID sets the ID field of the mutation.
func withMindmapID(id string) mindmapOption {
	return func(m *MindmapMutation) {
		var (
			err   error
			once  sync.Once
			value *Mindmap
		)
		m.oldValue = func(ctx context.Context) (*Mindmap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mindmap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMindmap sets the old Mindmap of the mutation.
func withMindmap(node *Mindmap) mindmapOption {
	return func(m *MindmapMutation) {
		m.oldValue = func(context.Context) (*Mindmap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MindmapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MindmapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mindmap entities.
func (m *MindmapMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MindmapMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MindmapMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mindmap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *MindmapMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MindmapMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *MindmapMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *MindmapMutation) SetContent(jm json.RawMessage) {
	m.content = &jm
	m.appendcontent = nil
}

// Content returns the value of the "content" field in the mutation.
func (m *MindmapMutation) Content() (r json.RawMessage, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldContent(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// AppendContent adds jm to the "content" field.
func (m *MindmapMutation) AppendContent(jm json.RawMessage) {
	m.appendcontent = append(m.appendcontent, jm...)
}

// AppendedContent returns the list of values that were appended to the "content" field in this mutation.
func (m *MindmapMutation) AppendedContent() (json.RawMessage, bool) {
	if len(m.appendcontent) == 0 {
		return nil, false
	}
	return m.appendcontent, true
}

// ResetContent resets all changes to the "content" field.
func (m *MindmapMutation) ResetContent() {
	m.content = nil
	m.appendcontent = nil
}

// SetIsPublic sets the "isPublic" field.
func (m *MindmapMutation) SetIsPublic(b bool) {
	m.isPublic = &b
}

// IsPublic returns the value of the "isPublic" field in the mutation.
func (m *MindmapMutation) IsPublic() (r bool, exists bool) {
	v := m.isPublic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "isPublic" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "isPublic" field.
func (m *MindmapMutation) ResetIsPublic() {
	m.isPublic = nil
}

// SetTags sets the "tags" field.
func (m *MindmapMutation) SetTags(jm json.RawMessage) {
	m.tags = &jm
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *MindmapMutation) Tags() (r json.RawMessage, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldTags(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds jm to the "tags" field.
func (m *MindmapMutation) AppendTags(jm json.RawMessage) {
	m.appendtags = append(m.appendtags, jm...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *MindmapMutation) AppendedTags() (json.RawMessage, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *MindmapMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *MindmapMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *MindmapMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *MindmapMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *MindmapMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *MindmapMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *MindmapMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetOwnerId sets the "ownerId" field.
func (m *MindmapMutation) SetOwnerId(s string) {
	m.user = &s
}

// OwnerId returns the value of the "ownerId" field in the mutation.
func (m *MindmapMutation) OwnerId() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerId returns the old "ownerId" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldOwnerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerId: %w", err)
	}
	return oldValue.OwnerId, nil
}

// ClearOwnerId clears the value of the "ownerId" field.
func (m *MindmapMutation) ClearOwnerId() {
	m.user = nil
	m.clearedFields[mindmap.FieldOwnerId] = struct{}{}
}

// OwnerIdCleared returns if the "ownerId" field was cleared in this mutation.
func (m *MindmapMutation) OwnerIdCleared() bool {
	_, ok := m.clearedFields[mindmap.FieldOwnerId]
	return ok
}

// ResetOwnerId resets all changes to the "ownerId" field.
func (m *MindmapMutation) ResetOwnerId() {
	m.user = nil
	delete(m.clearedFields, mindmap.FieldOwnerId)
}

// SetViews sets the "views" field.
func (m *MindmapMutation) SetViews(i int32) {
	m.views = &i
	m.addviews = nil
}

// Views returns the value of the "views" field in the mutation.
func (m *MindmapMutation) Views() (r int32, exists bool) {
	v := m.views
	if v == nil {
		return
	}
	return *v, true
}

// OldViews returns the old "views" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldViews(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViews: %w", err)
	}
	return oldValue.Views, nil
}

// AddViews adds i to the "views" field.
func (m *MindmapMutation) AddViews(i int32) {
	if m.addviews != nil {
		*m.addviews += i
	} else {
		m.addviews = &i
	}
}

// AddedViews returns the value that was added to the "views" field in this mutation.
func (m *MindmapMutation) AddedViews() (r int32, exists bool) {
	v := m.addviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetViews resets all changes to the "views" field.
func (m *MindmapMutation) ResetViews() {
	m.views = nil
	m.addviews = nil
}

// SetLikes sets the "likes" field.
func (m *MindmapMutation) SetLikes(i int32) {
	m.likes = &i
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *MindmapMutation) Likes() (r int32, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldLikes(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds i to the "likes" field.
func (m *MindmapMutation) AddLikes(i int32) {
	if m.addlikes != nil {
		*m.addlikes += i
	} else {
		m.addlikes = &i
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *MindmapMutation) AddedLikes() (r int32, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikes resets all changes to the "likes" field.
func (m *MindmapMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
}

// SetSummary sets the "summary" field.
func (m *MindmapMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *MindmapMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *MindmapMutation) ResetSummary() {
	m.summary = nil
}

// SetExtraData sets the "extraData" field.
func (m *MindmapMutation) SetExtraData(jm json.RawMessage) {
	m.extraData = &jm
	m.appendextraData = nil
}

// ExtraData returns the value of the "extraData" field in the mutation.
func (m *MindmapMutation) ExtraData() (r json.RawMessage, exists bool) {
	v := m.extraData
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extraData" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldExtraData(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// AppendExtraData adds jm to the "extraData" field.
func (m *MindmapMutation) AppendExtraData(jm json.RawMessage) {
	m.appendextraData = append(m.appendextraData, jm...)
}

// AppendedExtraData returns the list of values that were appended to the "extraData" field in this mutation.
func (m *MindmapMutation) AppendedExtraData() (json.RawMessage, bool) {
	if len(m.appendextraData) == 0 {
		return nil, false
	}
	return m.appendextraData, true
}

// ResetExtraData resets all changes to the "extraData" field.
func (m *MindmapMutation) ResetExtraData() {
	m.extraData = nil
	m.appendextraData = nil
}

// SetCategory sets the "category" field.
func (m *MindmapMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *MindmapMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Mindmap entity.
// If the Mindmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MindmapMutation) ResetCategory() {
	m.category = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MindmapMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MindmapMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[mindmap.FieldOwnerId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MindmapMutation) UserCleared() bool {
	return m.OwnerIdCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MindmapMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MindmapMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MindmapMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MindmapMutation builder.
func (m *MindmapMutation) Where(ps ...predicate.Mindmap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MindmapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MindmapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mindmap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MindmapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MindmapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mindmap).
func (m *MindmapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MindmapMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.title != nil {
		fields = append(fields, mindmap.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, mindmap.FieldContent)
	}
	if m.isPublic != nil {
		fields = append(fields, mindmap.FieldIsPublic)
	}
	if m.tags != nil {
		fields = append(fields, mindmap.FieldTags)
	}
	if m.createdAt != nil {
		fields = append(fields, mindmap.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, mindmap.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, mindmap.FieldOwnerId)
	}
	if m.views != nil {
		fields = append(fields, mindmap.FieldViews)
	}
	if m.likes != nil {
		fields = append(fields, mindmap.FieldLikes)
	}
	if m.summary != nil {
		fields = append(fields, mindmap.FieldSummary)
	}
	if m.extraData != nil {
		fields = append(fields, mindmap.FieldExtraData)
	}
	if m.category != nil {
		fields = append(fields, mindmap.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MindmapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mindmap.FieldTitle:
		return m.Title()
	case mindmap.FieldContent:
		return m.Content()
	case mindmap.FieldIsPublic:
		return m.IsPublic()
	case mindmap.FieldTags:
		return m.Tags()
	case mindmap.FieldCreatedAt:
		return m.CreatedAt()
	case mindmap.FieldUpdatedAt:
		return m.UpdatedAt()
	case mindmap.FieldOwnerId:
		return m.OwnerId()
	case mindmap.FieldViews:
		return m.Views()
	case mindmap.FieldLikes:
		return m.Likes()
	case mindmap.FieldSummary:
		return m.Summary()
	case mindmap.FieldExtraData:
		return m.ExtraData()
	case mindmap.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MindmapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mindmap.FieldTitle:
		return m.OldTitle(ctx)
	case mindmap.FieldContent:
		return m.OldContent(ctx)
	case mindmap.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case mindmap.FieldTags:
		return m.OldTags(ctx)
	case mindmap.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mindmap.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mindmap.FieldOwnerId:
		return m.OldOwnerId(ctx)
	case mindmap.FieldViews:
		return m.OldViews(ctx)
	case mindmap.FieldLikes:
		return m.OldLikes(ctx)
	case mindmap.FieldSummary:
		return m.OldSummary(ctx)
	case mindmap.FieldExtraData:
		return m.OldExtraData(ctx)
	case mindmap.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Mindmap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MindmapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mindmap.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case mindmap.FieldContent:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case mindmap.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case mindmap.FieldTags:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case mindmap.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mindmap.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mindmap.FieldOwnerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerId(v)
		return nil
	case mindmap.FieldViews:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViews(v)
		return nil
	case mindmap.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case mindmap.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case mindmap.FieldExtraData:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case mindmap.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Mindmap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MindmapMutation) AddedFields() []string {
	var fields []string
	if m.addviews != nil {
		fields = append(fields, mindmap.FieldViews)
	}
	if m.addlikes != nil {
		fields = append(fields, mindmap.FieldLikes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MindmapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mindmap.FieldViews:
		return m.AddedViews()
	case mindmap.FieldLikes:
		return m.AddedLikes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MindmapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mindmap.FieldViews:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViews(v)
		return nil
	case mindmap.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	}
	return fmt.Errorf("unknown Mindmap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MindmapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mindmap.FieldOwnerId) {
		fields = append(fields, mindmap.FieldOwnerId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MindmapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MindmapMutation) ClearField(name string) error {
	switch name {
	case mindmap.FieldOwnerId:
		m.ClearOwnerId()
		return nil
	}
	return fmt.Errorf("unknown Mindmap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MindmapMutation) ResetField(name string) error {
	switch name {
	case mindmap.FieldTitle:
		m.ResetTitle()
		return nil
	case mindmap.FieldContent:
		m.ResetContent()
		return nil
	case mindmap.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case mindmap.FieldTags:
		m.ResetTags()
		return nil
	case mindmap.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mindmap.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mindmap.FieldOwnerId:
		m.ResetOwnerId()
		return nil
	case mindmap.FieldViews:
		m.ResetViews()
		return nil
	case mindmap.FieldLikes:
		m.ResetLikes()
		return nil
	case mindmap.FieldSummary:
		m.ResetSummary()
		return nil
	case mindmap.FieldExtraData:
		m.ResetExtraData()
		return nil
	case mindmap.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Mindmap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MindmapMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, mindmap.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MindmapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mindmap.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MindmapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MindmapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MindmapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, mindmap.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MindmapMutation) EdgeCleared(name string) bool {
	switch name {
	case mindmap.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MindmapMutation) ClearEdge(name string) error {
	switch name {
	case mindmap.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Mindmap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MindmapMutation) ResetEdge(name string) error {
	switch name {
	case mindmap.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Mindmap edge %s", name)
}

// MomentMutation represents an operation that mutates the Moment nodes in the graph.
type MomentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	content              *string
	category             *string
	createdAt            *time.Time
	updatedAt            *time.Time
	isPublic             *bool
	likes                *int32
	addlikes             *int32
	tags                 *json.RawMessage
	appendtags           json.RawMessage
	views                *int32
	addviews             *int32
	extraData            *json.RawMessage
	appendextraData      json.RawMessage
	content_vector       *json.RawMessage
	appendcontent_vector json.RawMessage
	clearedFields        map[string]struct{}
	moment_images        map[uint]struct{}
	removedmoment_images map[uint]struct{}
	clearedmoment_images bool
	moment_videos        map[uint]struct{}
	removedmoment_videos map[uint]struct{}
	clearedmoment_videos bool
	user                 *string
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Moment, error)
	predicates           []predicate.Moment
}

var _ ent.Mutation = (*MomentMutation)(nil)

// momentOption allows management of the mutation configuration using functional options.
type momentOption func(*MomentMutation)

// newMomentMutation creates new mutation for the Moment entity.
func newMomentMutation(c config, op Op, opts ...momentOption) *MomentMutation {
	m := &MomentMutation{
		config:        c,
		op:            op,
		typ:           TypeMoment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMomentID sets the ID field of the mutation.
func withMomentID(id string) momentOption {
	return func(m *MomentMutation) {
		var (
			err   error
			once  sync.Once
			value *Moment
		)
		m.oldValue = func(ctx context.Context) (*Moment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Moment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMoment sets the old Moment of the mutation.
func withMoment(node *Moment) momentOption {
	return func(m *MomentMutation) {
		m.oldValue = func(context.Context) (*Moment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MomentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MomentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Moment entities.
func (m *MomentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MomentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MomentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Moment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *MomentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MomentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MomentMutation) ResetContent() {
	m.content = nil
}

// SetCategory sets the "category" field.
func (m *MomentMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *MomentMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MomentMutation) ResetCategory() {
	m.category = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *MomentMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *MomentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *MomentMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *MomentMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *MomentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *MomentMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetOwnerId sets the "ownerId" field.
func (m *MomentMutation) SetOwnerId(s string) {
	m.user = &s
}

// OwnerId returns the value of the "ownerId" field in the mutation.
func (m *MomentMutation) OwnerId() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerId returns the old "ownerId" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldOwnerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerId: %w", err)
	}
	return oldValue.OwnerId, nil
}

// ClearOwnerId clears the value of the "ownerId" field.
func (m *MomentMutation) ClearOwnerId() {
	m.user = nil
	m.clearedFields[moment.FieldOwnerId] = struct{}{}
}

// OwnerIdCleared returns if the "ownerId" field was cleared in this mutation.
func (m *MomentMutation) OwnerIdCleared() bool {
	_, ok := m.clearedFields[moment.FieldOwnerId]
	return ok
}

// ResetOwnerId resets all changes to the "ownerId" field.
func (m *MomentMutation) ResetOwnerId() {
	m.user = nil
	delete(m.clearedFields, moment.FieldOwnerId)
}

// SetIsPublic sets the "isPublic" field.
func (m *MomentMutation) SetIsPublic(b bool) {
	m.isPublic = &b
}

// IsPublic returns the value of the "isPublic" field in the mutation.
func (m *MomentMutation) IsPublic() (r bool, exists bool) {
	v := m.isPublic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "isPublic" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "isPublic" field.
func (m *MomentMutation) ResetIsPublic() {
	m.isPublic = nil
}

// SetLikes sets the "likes" field.
func (m *MomentMutation) SetLikes(i int32) {
	m.likes = &i
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *MomentMutation) Likes() (r int32, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldLikes(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds i to the "likes" field.
func (m *MomentMutation) AddLikes(i int32) {
	if m.addlikes != nil {
		*m.addlikes += i
	} else {
		m.addlikes = &i
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *MomentMutation) AddedLikes() (r int32, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikes resets all changes to the "likes" field.
func (m *MomentMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
}

// SetTags sets the "tags" field.
func (m *MomentMutation) SetTags(jm json.RawMessage) {
	m.tags = &jm
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *MomentMutation) Tags() (r json.RawMessage, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldTags(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds jm to the "tags" field.
func (m *MomentMutation) AppendTags(jm json.RawMessage) {
	m.appendtags = append(m.appendtags, jm...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *MomentMutation) AppendedTags() (json.RawMessage, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *MomentMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetViews sets the "views" field.
func (m *MomentMutation) SetViews(i int32) {
	m.views = &i
	m.addviews = nil
}

// Views returns the value of the "views" field in the mutation.
func (m *MomentMutation) Views() (r int32, exists bool) {
	v := m.views
	if v == nil {
		return
	}
	return *v, true
}

// OldViews returns the old "views" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldViews(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViews: %w", err)
	}
	return oldValue.Views, nil
}

// AddViews adds i to the "views" field.
func (m *MomentMutation) AddViews(i int32) {
	if m.addviews != nil {
		*m.addviews += i
	} else {
		m.addviews = &i
	}
}

// AddedViews returns the value that was added to the "views" field in this mutation.
func (m *MomentMutation) AddedViews() (r int32, exists bool) {
	v := m.addviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetViews resets all changes to the "views" field.
func (m *MomentMutation) ResetViews() {
	m.views = nil
	m.addviews = nil
}

// SetExtraData sets the "extraData" field.
func (m *MomentMutation) SetExtraData(jm json.RawMessage) {
	m.extraData = &jm
	m.appendextraData = nil
}

// ExtraData returns the value of the "extraData" field in the mutation.
func (m *MomentMutation) ExtraData() (r json.RawMessage, exists bool) {
	v := m.extraData
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extraData" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldExtraData(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// AppendExtraData adds jm to the "extraData" field.
func (m *MomentMutation) AppendExtraData(jm json.RawMessage) {
	m.appendextraData = append(m.appendextraData, jm...)
}

// AppendedExtraData returns the list of values that were appended to the "extraData" field in this mutation.
func (m *MomentMutation) AppendedExtraData() (json.RawMessage, bool) {
	if len(m.appendextraData) == 0 {
		return nil, false
	}
	return m.appendextraData, true
}

// ResetExtraData resets all changes to the "extraData" field.
func (m *MomentMutation) ResetExtraData() {
	m.extraData = nil
	m.appendextraData = nil
}

// SetContentVector sets the "content_vector" field.
func (m *MomentMutation) SetContentVector(jm json.RawMessage) {
	m.content_vector = &jm
	m.appendcontent_vector = nil
}

// ContentVector returns the value of the "content_vector" field in the mutation.
func (m *MomentMutation) ContentVector() (r json.RawMessage, exists bool) {
	v := m.content_vector
	if v == nil {
		return
	}
	return *v, true
}

// OldContentVector returns the old "content_vector" field's value of the Moment entity.
// If the Moment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentMutation) OldContentVector(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentVector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentVector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentVector: %w", err)
	}
	return oldValue.ContentVector, nil
}

// AppendContentVector adds jm to the "content_vector" field.
func (m *MomentMutation) AppendContentVector(jm json.RawMessage) {
	m.appendcontent_vector = append(m.appendcontent_vector, jm...)
}

// AppendedContentVector returns the list of values that were appended to the "content_vector" field in this mutation.
func (m *MomentMutation) AppendedContentVector() (json.RawMessage, bool) {
	if len(m.appendcontent_vector) == 0 {
		return nil, false
	}
	return m.appendcontent_vector, true
}

// ClearContentVector clears the value of the "content_vector" field.
func (m *MomentMutation) ClearContentVector() {
	m.content_vector = nil
	m.appendcontent_vector = nil
	m.clearedFields[moment.FieldContentVector] = struct{}{}
}

// ContentVectorCleared returns if the "content_vector" field was cleared in this mutation.
func (m *MomentMutation) ContentVectorCleared() bool {
	_, ok := m.clearedFields[moment.FieldContentVector]
	return ok
}

// ResetContentVector resets all changes to the "content_vector" field.
func (m *MomentMutation) ResetContentVector() {
	m.content_vector = nil
	m.appendcontent_vector = nil
	delete(m.clearedFields, moment.FieldContentVector)
}

// AddMomentImageIDs adds the "moment_images" edge to the MomentImage entity by ids.
func (m *MomentMutation) AddMomentImageIDs(ids ...uint) {
	if m.moment_images == nil {
		m.moment_images = make(map[uint]struct{})
	}
	for i := range ids {
		m.moment_images[ids[i]] = struct{}{}
	}
}

// ClearMomentImages clears the "moment_images" edge to the MomentImage entity.
func (m *MomentMutation) ClearMomentImages() {
	m.clearedmoment_images = true
}

// MomentImagesCleared reports if the "moment_images" edge to the MomentImage entity was cleared.
func (m *MomentMutation) MomentImagesCleared() bool {
	return m.clearedmoment_images
}

// RemoveMomentImageIDs removes the "moment_images" edge to the MomentImage entity by IDs.
func (m *MomentMutation) RemoveMomentImageIDs(ids ...uint) {
	if m.removedmoment_images == nil {
		m.removedmoment_images = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.moment_images, ids[i])
		m.removedmoment_images[ids[i]] = struct{}{}
	}
}

// RemovedMomentImages returns the removed IDs of the "moment_images" edge to the MomentImage entity.
func (m *MomentMutation) RemovedMomentImagesIDs() (ids []uint) {
	for id := range m.removedmoment_images {
		ids = append(ids, id)
	}
	return
}

// MomentImagesIDs returns the "moment_images" edge IDs in the mutation.
func (m *MomentMutation) MomentImagesIDs() (ids []uint) {
	for id := range m.moment_images {
		ids = append(ids, id)
	}
	return
}

// ResetMomentImages resets all changes to the "moment_images" edge.
func (m *MomentMutation) ResetMomentImages() {
	m.moment_images = nil
	m.clearedmoment_images = false
	m.removedmoment_images = nil
}

// AddMomentVideoIDs adds the "moment_videos" edge to the MomentVideo entity by ids.
func (m *MomentMutation) AddMomentVideoIDs(ids ...uint) {
	if m.moment_videos == nil {
		m.moment_videos = make(map[uint]struct{})
	}
	for i := range ids {
		m.moment_videos[ids[i]] = struct{}{}
	}
}

// ClearMomentVideos clears the "moment_videos" edge to the MomentVideo entity.
func (m *MomentMutation) ClearMomentVideos() {
	m.clearedmoment_videos = true
}

// MomentVideosCleared reports if the "moment_videos" edge to the MomentVideo entity was cleared.
func (m *MomentMutation) MomentVideosCleared() bool {
	return m.clearedmoment_videos
}

// RemoveMomentVideoIDs removes the "moment_videos" edge to the MomentVideo entity by IDs.
func (m *MomentMutation) RemoveMomentVideoIDs(ids ...uint) {
	if m.removedmoment_videos == nil {
		m.removedmoment_videos = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.moment_videos, ids[i])
		m.removedmoment_videos[ids[i]] = struct{}{}
	}
}

// RemovedMomentVideos returns the removed IDs of the "moment_videos" edge to the MomentVideo entity.
func (m *MomentMutation) RemovedMomentVideosIDs() (ids []uint) {
	for id := range m.removedmoment_videos {
		ids = append(ids, id)
	}
	return
}

// MomentVideosIDs returns the "moment_videos" edge IDs in the mutation.
func (m *MomentMutation) MomentVideosIDs() (ids []uint) {
	for id := range m.moment_videos {
		ids = append(ids, id)
	}
	return
}

// ResetMomentVideos resets all changes to the "moment_videos" edge.
func (m *MomentMutation) ResetMomentVideos() {
	m.moment_videos = nil
	m.clearedmoment_videos = false
	m.removedmoment_videos = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MomentMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MomentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[moment.FieldOwnerId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MomentMutation) UserCleared() bool {
	return m.OwnerIdCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MomentMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MomentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MomentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MomentMutation builder.
func (m *MomentMutation) Where(ps ...predicate.Moment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MomentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MomentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Moment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MomentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MomentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Moment).
func (m *MomentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MomentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.content != nil {
		fields = append(fields, moment.FieldContent)
	}
	if m.category != nil {
		fields = append(fields, moment.FieldCategory)
	}
	if m.createdAt != nil {
		fields = append(fields, moment.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, moment.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, moment.FieldOwnerId)
	}
	if m.isPublic != nil {
		fields = append(fields, moment.FieldIsPublic)
	}
	if m.likes != nil {
		fields = append(fields, moment.FieldLikes)
	}
	if m.tags != nil {
		fields = append(fields, moment.FieldTags)
	}
	if m.views != nil {
		fields = append(fields, moment.FieldViews)
	}
	if m.extraData != nil {
		fields = append(fields, moment.FieldExtraData)
	}
	if m.content_vector != nil {
		fields = append(fields, moment.FieldContentVector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MomentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case moment.FieldContent:
		return m.Content()
	case moment.FieldCategory:
		return m.Category()
	case moment.FieldCreatedAt:
		return m.CreatedAt()
	case moment.FieldUpdatedAt:
		return m.UpdatedAt()
	case moment.FieldOwnerId:
		return m.OwnerId()
	case moment.FieldIsPublic:
		return m.IsPublic()
	case moment.FieldLikes:
		return m.Likes()
	case moment.FieldTags:
		return m.Tags()
	case moment.FieldViews:
		return m.Views()
	case moment.FieldExtraData:
		return m.ExtraData()
	case moment.FieldContentVector:
		return m.ContentVector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MomentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case moment.FieldContent:
		return m.OldContent(ctx)
	case moment.FieldCategory:
		return m.OldCategory(ctx)
	case moment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case moment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case moment.FieldOwnerId:
		return m.OldOwnerId(ctx)
	case moment.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case moment.FieldLikes:
		return m.OldLikes(ctx)
	case moment.FieldTags:
		return m.OldTags(ctx)
	case moment.FieldViews:
		return m.OldViews(ctx)
	case moment.FieldExtraData:
		return m.OldExtraData(ctx)
	case moment.FieldContentVector:
		return m.OldContentVector(ctx)
	}
	return nil, fmt.Errorf("unknown Moment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MomentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case moment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case moment.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case moment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case moment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case moment.FieldOwnerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerId(v)
		return nil
	case moment.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case moment.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case moment.FieldTags:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case moment.FieldViews:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViews(v)
		return nil
	case moment.FieldExtraData:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case moment.FieldContentVector:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentVector(v)
		return nil
	}
	return fmt.Errorf("unknown Moment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MomentMutation) AddedFields() []string {
	var fields []string
	if m.addlikes != nil {
		fields = append(fields, moment.FieldLikes)
	}
	if m.addviews != nil {
		fields = append(fields, moment.FieldViews)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MomentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case moment.FieldLikes:
		return m.AddedLikes()
	case moment.FieldViews:
		return m.AddedViews()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MomentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case moment.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	case moment.FieldViews:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViews(v)
		return nil
	}
	return fmt.Errorf("unknown Moment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MomentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(moment.FieldOwnerId) {
		fields = append(fields, moment.FieldOwnerId)
	}
	if m.FieldCleared(moment.FieldContentVector) {
		fields = append(fields, moment.FieldContentVector)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MomentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MomentMutation) ClearField(name string) error {
	switch name {
	case moment.FieldOwnerId:
		m.ClearOwnerId()
		return nil
	case moment.FieldContentVector:
		m.ClearContentVector()
		return nil
	}
	return fmt.Errorf("unknown Moment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MomentMutation) ResetField(name string) error {
	switch name {
	case moment.FieldContent:
		m.ResetContent()
		return nil
	case moment.FieldCategory:
		m.ResetCategory()
		return nil
	case moment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case moment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case moment.FieldOwnerId:
		m.ResetOwnerId()
		return nil
	case moment.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case moment.FieldLikes:
		m.ResetLikes()
		return nil
	case moment.FieldTags:
		m.ResetTags()
		return nil
	case moment.FieldViews:
		m.ResetViews()
		return nil
	case moment.FieldExtraData:
		m.ResetExtraData()
		return nil
	case moment.FieldContentVector:
		m.ResetContentVector()
		return nil
	}
	return fmt.Errorf("unknown Moment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MomentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.moment_images != nil {
		edges = append(edges, moment.EdgeMomentImages)
	}
	if m.moment_videos != nil {
		edges = append(edges, moment.EdgeMomentVideos)
	}
	if m.user != nil {
		edges = append(edges, moment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MomentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case moment.EdgeMomentImages:
		ids := make([]ent.Value, 0, len(m.moment_images))
		for id := range m.moment_images {
			ids = append(ids, id)
		}
		return ids
	case moment.EdgeMomentVideos:
		ids := make([]ent.Value, 0, len(m.moment_videos))
		for id := range m.moment_videos {
			ids = append(ids, id)
		}
		return ids
	case moment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MomentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmoment_images != nil {
		edges = append(edges, moment.EdgeMomentImages)
	}
	if m.removedmoment_videos != nil {
		edges = append(edges, moment.EdgeMomentVideos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MomentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case moment.EdgeMomentImages:
		ids := make([]ent.Value, 0, len(m.removedmoment_images))
		for id := range m.removedmoment_images {
			ids = append(ids, id)
		}
		return ids
	case moment.EdgeMomentVideos:
		ids := make([]ent.Value, 0, len(m.removedmoment_videos))
		for id := range m.removedmoment_videos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MomentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmoment_images {
		edges = append(edges, moment.EdgeMomentImages)
	}
	if m.clearedmoment_videos {
		edges = append(edges, moment.EdgeMomentVideos)
	}
	if m.cleareduser {
		edges = append(edges, moment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MomentMutation) EdgeCleared(name string) bool {
	switch name {
	case moment.EdgeMomentImages:
		return m.clearedmoment_images
	case moment.EdgeMomentVideos:
		return m.clearedmoment_videos
	case moment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MomentMutation) ClearEdge(name string) error {
	switch name {
	case moment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Moment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MomentMutation) ResetEdge(name string) error {
	switch name {
	case moment.EdgeMomentImages:
		m.ResetMomentImages()
		return nil
	case moment.EdgeMomentVideos:
		m.ResetMomentVideos()
		return nil
	case moment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Moment edge %s", name)
}

// MomentImageMutation represents an operation that mutates the MomentImage nodes in the graph.
type MomentImageMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	sort          *int32
	addsort       *int32
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	image         *string
	clearedimage  bool
	moment        *string
	clearedmoment bool
	done          bool
	oldValue      func(context.Context) (*MomentImage, error)
	predicates    []predicate.MomentImage
}

var _ ent.Mutation = (*MomentImageMutation)(nil)

// momentimageOption allows management of the mutation configuration using functional options.
type momentimageOption func(*MomentImageMutation)

// newMomentImageMutation creates new mutation for the MomentImage entity.
func newMomentImageMutation(c config, op Op, opts ...momentimageOption) *MomentImageMutation {
	m := &MomentImageMutation{
		config:        c,
		op:            op,
		typ:           TypeMomentImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMomentImageID sets the ID field of the mutation.
func withMomentImageID(id uint) momentimageOption {
	return func(m *MomentImageMutation) {
		var (
			err   error
			once  sync.Once
			value *MomentImage
		)
		m.oldValue = func(ctx context.Context) (*MomentImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MomentImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMomentImage sets the old MomentImage of the mutation.
func withMomentImage(node *MomentImage) momentimageOption {
	return func(m *MomentImageMutation) {
		m.oldValue = func(context.Context) (*MomentImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MomentImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MomentImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MomentImage entities.
func (m *MomentImageMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MomentImageMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MomentImageMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MomentImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImageId sets the "imageId" field.
func (m *MomentImageMutation) SetImageId(s string) {
	m.image = &s
}

// ImageId returns the value of the "imageId" field in the mutation.
func (m *MomentImageMutation) ImageId() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImageId returns the old "imageId" field's value of the MomentImage entity.
// If the MomentImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentImageMutation) OldImageId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageId: %w", err)
	}
	return oldValue.ImageId, nil
}

// ClearImageId clears the value of the "imageId" field.
func (m *MomentImageMutation) ClearImageId() {
	m.image = nil
	m.clearedFields[momentimage.FieldImageId] = struct{}{}
}

// ImageIdCleared returns if the "imageId" field was cleared in this mutation.
func (m *MomentImageMutation) ImageIdCleared() bool {
	_, ok := m.clearedFields[momentimage.FieldImageId]
	return ok
}

// ResetImageId resets all changes to the "imageId" field.
func (m *MomentImageMutation) ResetImageId() {
	m.image = nil
	delete(m.clearedFields, momentimage.FieldImageId)
}

// SetMomentId sets the "momentId" field.
func (m *MomentImageMutation) SetMomentId(s string) {
	m.moment = &s
}

// MomentId returns the value of the "momentId" field in the mutation.
func (m *MomentImageMutation) MomentId() (r string, exists bool) {
	v := m.moment
	if v == nil {
		return
	}
	return *v, true
}

// OldMomentId returns the old "momentId" field's value of the MomentImage entity.
// If the MomentImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentImageMutation) OldMomentId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMomentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMomentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMomentId: %w", err)
	}
	return oldValue.MomentId, nil
}

// ClearMomentId clears the value of the "momentId" field.
func (m *MomentImageMutation) ClearMomentId() {
	m.moment = nil
	m.clearedFields[momentimage.FieldMomentId] = struct{}{}
}

// MomentIdCleared returns if the "momentId" field was cleared in this mutation.
func (m *MomentImageMutation) MomentIdCleared() bool {
	_, ok := m.clearedFields[momentimage.FieldMomentId]
	return ok
}

// ResetMomentId resets all changes to the "momentId" field.
func (m *MomentImageMutation) ResetMomentId() {
	m.moment = nil
	delete(m.clearedFields, momentimage.FieldMomentId)
}

// SetSort sets the "sort" field.
func (m *MomentImageMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *MomentImageMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the MomentImage entity.
// If the MomentImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentImageMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *MomentImageMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *MomentImageMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *MomentImageMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *MomentImageMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *MomentImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the MomentImage entity.
// If the MomentImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *MomentImageMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *MomentImageMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *MomentImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the MomentImage entity.
// If the MomentImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *MomentImageMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetImageID sets the "image" edge to the Image entity by id.
func (m *MomentImageMutation) SetImageID(id string) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Image entity.
func (m *MomentImageMutation) ClearImage() {
	m.clearedimage = true
	m.clearedFields[momentimage.FieldImageId] = struct{}{}
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *MomentImageMutation) ImageCleared() bool {
	return m.ImageIdCleared() || m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *MomentImageMutation) ImageID() (id string, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *MomentImageMutation) ImageIDs() (ids []string) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *MomentImageMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// SetMomentID sets the "moment" edge to the Moment entity by id.
func (m *MomentImageMutation) SetMomentID(id string) {
	m.moment = &id
}

// ClearMoment clears the "moment" edge to the Moment entity.
func (m *MomentImageMutation) ClearMoment() {
	m.clearedmoment = true
	m.clearedFields[momentimage.FieldMomentId] = struct{}{}
}

// MomentCleared reports if the "moment" edge to the Moment entity was cleared.
func (m *MomentImageMutation) MomentCleared() bool {
	return m.MomentIdCleared() || m.clearedmoment
}

// MomentID returns the "moment" edge ID in the mutation.
func (m *MomentImageMutation) MomentID() (id string, exists bool) {
	if m.moment != nil {
		return *m.moment, true
	}
	return
}

// MomentIDs returns the "moment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MomentID instead. It exists only for internal usage by the builders.
func (m *MomentImageMutation) MomentIDs() (ids []string) {
	if id := m.moment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMoment resets all changes to the "moment" edge.
func (m *MomentImageMutation) ResetMoment() {
	m.moment = nil
	m.clearedmoment = false
}

// Where appends a list predicates to the MomentImageMutation builder.
func (m *MomentImageMutation) Where(ps ...predicate.MomentImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MomentImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MomentImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MomentImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MomentImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MomentImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MomentImage).
func (m *MomentImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MomentImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.image != nil {
		fields = append(fields, momentimage.FieldImageId)
	}
	if m.moment != nil {
		fields = append(fields, momentimage.FieldMomentId)
	}
	if m.sort != nil {
		fields = append(fields, momentimage.FieldSort)
	}
	if m.createdAt != nil {
		fields = append(fields, momentimage.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, momentimage.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MomentImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case momentimage.FieldImageId:
		return m.ImageId()
	case momentimage.FieldMomentId:
		return m.MomentId()
	case momentimage.FieldSort:
		return m.Sort()
	case momentimage.FieldCreatedAt:
		return m.CreatedAt()
	case momentimage.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MomentImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case momentimage.FieldImageId:
		return m.OldImageId(ctx)
	case momentimage.FieldMomentId:
		return m.OldMomentId(ctx)
	case momentimage.FieldSort:
		return m.OldSort(ctx)
	case momentimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case momentimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MomentImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MomentImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case momentimage.FieldImageId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageId(v)
		return nil
	case momentimage.FieldMomentId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMomentId(v)
		return nil
	case momentimage.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case momentimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case momentimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MomentImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MomentImageMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, momentimage.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MomentImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case momentimage.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MomentImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case momentimage.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown MomentImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MomentImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(momentimage.FieldImageId) {
		fields = append(fields, momentimage.FieldImageId)
	}
	if m.FieldCleared(momentimage.FieldMomentId) {
		fields = append(fields, momentimage.FieldMomentId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MomentImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MomentImageMutation) ClearField(name string) error {
	switch name {
	case momentimage.FieldImageId:
		m.ClearImageId()
		return nil
	case momentimage.FieldMomentId:
		m.ClearMomentId()
		return nil
	}
	return fmt.Errorf("unknown MomentImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MomentImageMutation) ResetField(name string) error {
	switch name {
	case momentimage.FieldImageId:
		m.ResetImageId()
		return nil
	case momentimage.FieldMomentId:
		m.ResetMomentId()
		return nil
	case momentimage.FieldSort:
		m.ResetSort()
		return nil
	case momentimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case momentimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MomentImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MomentImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.image != nil {
		edges = append(edges, momentimage.EdgeImage)
	}
	if m.moment != nil {
		edges = append(edges, momentimage.EdgeMoment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MomentImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case momentimage.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	case momentimage.EdgeMoment:
		if id := m.moment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MomentImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MomentImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MomentImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedimage {
		edges = append(edges, momentimage.EdgeImage)
	}
	if m.clearedmoment {
		edges = append(edges, momentimage.EdgeMoment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MomentImageMutation) EdgeCleared(name string) bool {
	switch name {
	case momentimage.EdgeImage:
		return m.clearedimage
	case momentimage.EdgeMoment:
		return m.clearedmoment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MomentImageMutation) ClearEdge(name string) error {
	switch name {
	case momentimage.EdgeImage:
		m.ClearImage()
		return nil
	case momentimage.EdgeMoment:
		m.ClearMoment()
		return nil
	}
	return fmt.Errorf("unknown MomentImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MomentImageMutation) ResetEdge(name string) error {
	switch name {
	case momentimage.EdgeImage:
		m.ResetImage()
		return nil
	case momentimage.EdgeMoment:
		m.ResetMoment()
		return nil
	}
	return fmt.Errorf("unknown MomentImage edge %s", name)
}

// MomentVideoMutation represents an operation that mutates the MomentVideo nodes in the graph.
type MomentVideoMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	sort          *int32
	addsort       *int32
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	moment        *string
	clearedmoment bool
	video         *string
	clearedvideo  bool
	done          bool
	oldValue      func(context.Context) (*MomentVideo, error)
	predicates    []predicate.MomentVideo
}

var _ ent.Mutation = (*MomentVideoMutation)(nil)

// momentvideoOption allows management of the mutation configuration using functional options.
type momentvideoOption func(*MomentVideoMutation)

// newMomentVideoMutation creates new mutation for the MomentVideo entity.
func newMomentVideoMutation(c config, op Op, opts ...momentvideoOption) *MomentVideoMutation {
	m := &MomentVideoMutation{
		config:        c,
		op:            op,
		typ:           TypeMomentVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMomentVideoID sets the ID field of the mutation.
func withMomentVideoID(id uint) momentvideoOption {
	return func(m *MomentVideoMutation) {
		var (
			err   error
			once  sync.Once
			value *MomentVideo
		)
		m.oldValue = func(ctx context.Context) (*MomentVideo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MomentVideo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMomentVideo sets the old MomentVideo of the mutation.
func withMomentVideo(node *MomentVideo) momentvideoOption {
	return func(m *MomentVideoMutation) {
		m.oldValue = func(context.Context) (*MomentVideo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MomentVideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MomentVideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MomentVideo entities.
func (m *MomentVideoMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MomentVideoMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MomentVideoMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MomentVideo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVideoId sets the "videoId" field.
func (m *MomentVideoMutation) SetVideoId(s string) {
	m.video = &s
}

// VideoId returns the value of the "videoId" field in the mutation.
func (m *MomentVideoMutation) VideoId() (r string, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoId returns the old "videoId" field's value of the MomentVideo entity.
// If the MomentVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentVideoMutation) OldVideoId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoId: %w", err)
	}
	return oldValue.VideoId, nil
}

// ClearVideoId clears the value of the "videoId" field.
func (m *MomentVideoMutation) ClearVideoId() {
	m.video = nil
	m.clearedFields[momentvideo.FieldVideoId] = struct{}{}
}

// VideoIdCleared returns if the "videoId" field was cleared in this mutation.
func (m *MomentVideoMutation) VideoIdCleared() bool {
	_, ok := m.clearedFields[momentvideo.FieldVideoId]
	return ok
}

// ResetVideoId resets all changes to the "videoId" field.
func (m *MomentVideoMutation) ResetVideoId() {
	m.video = nil
	delete(m.clearedFields, momentvideo.FieldVideoId)
}

// SetMomentId sets the "momentId" field.
func (m *MomentVideoMutation) SetMomentId(s string) {
	m.moment = &s
}

// MomentId returns the value of the "momentId" field in the mutation.
func (m *MomentVideoMutation) MomentId() (r string, exists bool) {
	v := m.moment
	if v == nil {
		return
	}
	return *v, true
}

// OldMomentId returns the old "momentId" field's value of the MomentVideo entity.
// If the MomentVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentVideoMutation) OldMomentId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMomentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMomentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMomentId: %w", err)
	}
	return oldValue.MomentId, nil
}

// ClearMomentId clears the value of the "momentId" field.
func (m *MomentVideoMutation) ClearMomentId() {
	m.moment = nil
	m.clearedFields[momentvideo.FieldMomentId] = struct{}{}
}

// MomentIdCleared returns if the "momentId" field was cleared in this mutation.
func (m *MomentVideoMutation) MomentIdCleared() bool {
	_, ok := m.clearedFields[momentvideo.FieldMomentId]
	return ok
}

// ResetMomentId resets all changes to the "momentId" field.
func (m *MomentVideoMutation) ResetMomentId() {
	m.moment = nil
	delete(m.clearedFields, momentvideo.FieldMomentId)
}

// SetSort sets the "sort" field.
func (m *MomentVideoMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *MomentVideoMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the MomentVideo entity.
// If the MomentVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentVideoMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *MomentVideoMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *MomentVideoMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *MomentVideoMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *MomentVideoMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *MomentVideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the MomentVideo entity.
// If the MomentVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentVideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *MomentVideoMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *MomentVideoMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *MomentVideoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the MomentVideo entity.
// If the MomentVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MomentVideoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *MomentVideoMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetMomentID sets the "moment" edge to the Moment entity by id.
func (m *MomentVideoMutation) SetMomentID(id string) {
	m.moment = &id
}

// ClearMoment clears the "moment" edge to the Moment entity.
func (m *MomentVideoMutation) ClearMoment() {
	m.clearedmoment = true
	m.clearedFields[momentvideo.FieldMomentId] = struct{}{}
}

// MomentCleared reports if the "moment" edge to the Moment entity was cleared.
func (m *MomentVideoMutation) MomentCleared() bool {
	return m.MomentIdCleared() || m.clearedmoment
}

// MomentID returns the "moment" edge ID in the mutation.
func (m *MomentVideoMutation) MomentID() (id string, exists bool) {
	if m.moment != nil {
		return *m.moment, true
	}
	return
}

// MomentIDs returns the "moment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MomentID instead. It exists only for internal usage by the builders.
func (m *MomentVideoMutation) MomentIDs() (ids []string) {
	if id := m.moment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMoment resets all changes to the "moment" edge.
func (m *MomentVideoMutation) ResetMoment() {
	m.moment = nil
	m.clearedmoment = false
}

// SetVideoID sets the "video" edge to the Video entity by id.
func (m *MomentVideoMutation) SetVideoID(id string) {
	m.video = &id
}

// ClearVideo clears the "video" edge to the Video entity.
func (m *MomentVideoMutation) ClearVideo() {
	m.clearedvideo = true
	m.clearedFields[momentvideo.FieldVideoId] = struct{}{}
}

// VideoCleared reports if the "video" edge to the Video entity was cleared.
func (m *MomentVideoMutation) VideoCleared() bool {
	return m.VideoIdCleared() || m.clearedvideo
}

// VideoID returns the "video" edge ID in the mutation.
func (m *MomentVideoMutation) VideoID() (id string, exists bool) {
	if m.video != nil {
		return *m.video, true
	}
	return
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *MomentVideoMutation) VideoIDs() (ids []string) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *MomentVideoMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// Where appends a list predicates to the MomentVideoMutation builder.
func (m *MomentVideoMutation) Where(ps ...predicate.MomentVideo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MomentVideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MomentVideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MomentVideo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MomentVideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MomentVideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MomentVideo).
func (m *MomentVideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MomentVideoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.video != nil {
		fields = append(fields, momentvideo.FieldVideoId)
	}
	if m.moment != nil {
		fields = append(fields, momentvideo.FieldMomentId)
	}
	if m.sort != nil {
		fields = append(fields, momentvideo.FieldSort)
	}
	if m.createdAt != nil {
		fields = append(fields, momentvideo.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, momentvideo.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MomentVideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case momentvideo.FieldVideoId:
		return m.VideoId()
	case momentvideo.FieldMomentId:
		return m.MomentId()
	case momentvideo.FieldSort:
		return m.Sort()
	case momentvideo.FieldCreatedAt:
		return m.CreatedAt()
	case momentvideo.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MomentVideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case momentvideo.FieldVideoId:
		return m.OldVideoId(ctx)
	case momentvideo.FieldMomentId:
		return m.OldMomentId(ctx)
	case momentvideo.FieldSort:
		return m.OldSort(ctx)
	case momentvideo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case momentvideo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MomentVideo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MomentVideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case momentvideo.FieldVideoId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoId(v)
		return nil
	case momentvideo.FieldMomentId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMomentId(v)
		return nil
	case momentvideo.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case momentvideo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case momentvideo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MomentVideo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MomentVideoMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, momentvideo.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MomentVideoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case momentvideo.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MomentVideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case momentvideo.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown MomentVideo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MomentVideoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(momentvideo.FieldVideoId) {
		fields = append(fields, momentvideo.FieldVideoId)
	}
	if m.FieldCleared(momentvideo.FieldMomentId) {
		fields = append(fields, momentvideo.FieldMomentId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MomentVideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MomentVideoMutation) ClearField(name string) error {
	switch name {
	case momentvideo.FieldVideoId:
		m.ClearVideoId()
		return nil
	case momentvideo.FieldMomentId:
		m.ClearMomentId()
		return nil
	}
	return fmt.Errorf("unknown MomentVideo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MomentVideoMutation) ResetField(name string) error {
	switch name {
	case momentvideo.FieldVideoId:
		m.ResetVideoId()
		return nil
	case momentvideo.FieldMomentId:
		m.ResetMomentId()
		return nil
	case momentvideo.FieldSort:
		m.ResetSort()
		return nil
	case momentvideo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case momentvideo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MomentVideo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MomentVideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.moment != nil {
		edges = append(edges, momentvideo.EdgeMoment)
	}
	if m.video != nil {
		edges = append(edges, momentvideo.EdgeVideo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MomentVideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case momentvideo.EdgeMoment:
		if id := m.moment; id != nil {
			return []ent.Value{*id}
		}
	case momentvideo.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MomentVideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MomentVideoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MomentVideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmoment {
		edges = append(edges, momentvideo.EdgeMoment)
	}
	if m.clearedvideo {
		edges = append(edges, momentvideo.EdgeVideo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MomentVideoMutation) EdgeCleared(name string) bool {
	switch name {
	case momentvideo.EdgeMoment:
		return m.clearedmoment
	case momentvideo.EdgeVideo:
		return m.clearedvideo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MomentVideoMutation) ClearEdge(name string) error {
	switch name {
	case momentvideo.EdgeMoment:
		m.ClearMoment()
		return nil
	case momentvideo.EdgeVideo:
		m.ClearVideo()
		return nil
	}
	return fmt.Errorf("unknown MomentVideo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MomentVideoMutation) ResetEdge(name string) error {
	switch name {
	case momentvideo.EdgeMoment:
		m.ResetMoment()
		return nil
	case momentvideo.EdgeVideo:
		m.ResetVideo()
		return nil
	}
	return fmt.Errorf("unknown MomentVideo edge %s", name)
}

// TodoMutation represents an operation that mutates the Todo nodes in the graph.
type TodoMutation struct {
	config
	op              Op
	typ             string
	id              *string
	title           *string
	content         *string
	status          *bool
	priority        *int32
	addpriority     *int32
	dueDate         *time.Time
	isPublic        *bool
	pinned          *bool
	createdAt       *time.Time
	updatedAt       *time.Time
	extraData       *json.RawMessage
	appendextraData json.RawMessage
	category        *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Todo, error)
	predicates      []predicate.Todo
}

var _ ent.Mutation = (*TodoMutation)(nil)

// todoOption allows management of the mutation configuration using functional options.
type todoOption func(*TodoMutation)

// newTodoMutation creates new mutation for the Todo entity.
func newTodoMutation(c config, op Op, opts ...todoOption) *TodoMutation {
	m := &TodoMutation{
		config:        c,
		op:            op,
		typ:           TypeTodo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTodoID sets the ID field of the mutation.
func withTodoID(id string) todoOption {
	return func(m *TodoMutation) {
		var (
			err   error
			once  sync.Once
			value *Todo
		)
		m.oldValue = func(ctx context.Context) (*Todo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Todo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTodo sets the old Todo of the mutation.
func withTodo(node *Todo) todoOption {
	return func(m *TodoMutation) {
		m.oldValue = func(context.Context) (*Todo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TodoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TodoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Todo entities.
func (m *TodoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TodoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TodoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Todo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *TodoMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TodoMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TodoMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *TodoMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *TodoMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *TodoMutation) ClearContent() {
	m.content = nil
	m.clearedFields[todo.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *TodoMutation) ContentCleared() bool {
	_, ok := m.clearedFields[todo.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *TodoMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, todo.FieldContent)
}

// SetStatus sets the "status" field.
func (m *TodoMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *TodoMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TodoMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TodoMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TodoMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldPriority(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *TodoMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *TodoMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *TodoMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetDueDate sets the "dueDate" field.
func (m *TodoMutation) SetDueDate(t time.Time) {
	m.dueDate = &t
}

// DueDate returns the value of the "dueDate" field in the mutation.
func (m *TodoMutation) DueDate() (r time.Time, exists bool) {
	v := m.dueDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "dueDate" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "dueDate" field.
func (m *TodoMutation) ClearDueDate() {
	m.dueDate = nil
	m.clearedFields[todo.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "dueDate" field was cleared in this mutation.
func (m *TodoMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[todo.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "dueDate" field.
func (m *TodoMutation) ResetDueDate() {
	m.dueDate = nil
	delete(m.clearedFields, todo.FieldDueDate)
}

// SetIsPublic sets the "isPublic" field.
func (m *TodoMutation) SetIsPublic(b bool) {
	m.isPublic = &b
}

// IsPublic returns the value of the "isPublic" field in the mutation.
func (m *TodoMutation) IsPublic() (r bool, exists bool) {
	v := m.isPublic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "isPublic" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "isPublic" field.
func (m *TodoMutation) ResetIsPublic() {
	m.isPublic = nil
}

// SetPinned sets the "pinned" field.
func (m *TodoMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *TodoMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *TodoMutation) ResetPinned() {
	m.pinned = nil
}

// SetOwnerId sets the "ownerId" field.
func (m *TodoMutation) SetOwnerId(s string) {
	m.user = &s
}

// OwnerId returns the value of the "ownerId" field in the mutation.
func (m *TodoMutation) OwnerId() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerId returns the old "ownerId" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldOwnerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerId: %w", err)
	}
	return oldValue.OwnerId, nil
}

// ClearOwnerId clears the value of the "ownerId" field.
func (m *TodoMutation) ClearOwnerId() {
	m.user = nil
	m.clearedFields[todo.FieldOwnerId] = struct{}{}
}

// OwnerIdCleared returns if the "ownerId" field was cleared in this mutation.
func (m *TodoMutation) OwnerIdCleared() bool {
	_, ok := m.clearedFields[todo.FieldOwnerId]
	return ok
}

// ResetOwnerId resets all changes to the "ownerId" field.
func (m *TodoMutation) ResetOwnerId() {
	m.user = nil
	delete(m.clearedFields, todo.FieldOwnerId)
}

// SetCreatedAt sets the "createdAt" field.
func (m *TodoMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TodoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TodoMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TodoMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TodoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TodoMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetExtraData sets the "extraData" field.
func (m *TodoMutation) SetExtraData(jm json.RawMessage) {
	m.extraData = &jm
	m.appendextraData = nil
}

// ExtraData returns the value of the "extraData" field in the mutation.
func (m *TodoMutation) ExtraData() (r json.RawMessage, exists bool) {
	v := m.extraData
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extraData" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldExtraData(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// AppendExtraData adds jm to the "extraData" field.
func (m *TodoMutation) AppendExtraData(jm json.RawMessage) {
	m.appendextraData = append(m.appendextraData, jm...)
}

// AppendedExtraData returns the list of values that were appended to the "extraData" field in this mutation.
func (m *TodoMutation) AppendedExtraData() (json.RawMessage, bool) {
	if len(m.appendextraData) == 0 {
		return nil, false
	}
	return m.appendextraData, true
}

// ResetExtraData resets all changes to the "extraData" field.
func (m *TodoMutation) ResetExtraData() {
	m.extraData = nil
	m.appendextraData = nil
}

// SetCategory sets the "category" field.
func (m *TodoMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TodoMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TodoMutation) ResetCategory() {
	m.category = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TodoMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TodoMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[todo.FieldOwnerId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TodoMutation) UserCleared() bool {
	return m.OwnerIdCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TodoMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TodoMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TodoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TodoMutation builder.
func (m *TodoMutation) Where(ps ...predicate.Todo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TodoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TodoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Todo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TodoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TodoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Todo).
func (m *TodoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TodoMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.title != nil {
		fields = append(fields, todo.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, todo.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, todo.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, todo.FieldPriority)
	}
	if m.dueDate != nil {
		fields = append(fields, todo.FieldDueDate)
	}
	if m.isPublic != nil {
		fields = append(fields, todo.FieldIsPublic)
	}
	if m.pinned != nil {
		fields = append(fields, todo.FieldPinned)
	}
	if m.user != nil {
		fields = append(fields, todo.FieldOwnerId)
	}
	if m.createdAt != nil {
		fields = append(fields, todo.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, todo.FieldUpdatedAt)
	}
	if m.extraData != nil {
		fields = append(fields, todo.FieldExtraData)
	}
	if m.category != nil {
		fields = append(fields, todo.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TodoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case todo.FieldTitle:
		return m.Title()
	case todo.FieldContent:
		return m.Content()
	case todo.FieldStatus:
		return m.Status()
	case todo.FieldPriority:
		return m.Priority()
	case todo.FieldDueDate:
		return m.DueDate()
	case todo.FieldIsPublic:
		return m.IsPublic()
	case todo.FieldPinned:
		return m.Pinned()
	case todo.FieldOwnerId:
		return m.OwnerId()
	case todo.FieldCreatedAt:
		return m.CreatedAt()
	case todo.FieldUpdatedAt:
		return m.UpdatedAt()
	case todo.FieldExtraData:
		return m.ExtraData()
	case todo.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TodoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case todo.FieldTitle:
		return m.OldTitle(ctx)
	case todo.FieldContent:
		return m.OldContent(ctx)
	case todo.FieldStatus:
		return m.OldStatus(ctx)
	case todo.FieldPriority:
		return m.OldPriority(ctx)
	case todo.FieldDueDate:
		return m.OldDueDate(ctx)
	case todo.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case todo.FieldPinned:
		return m.OldPinned(ctx)
	case todo.FieldOwnerId:
		return m.OldOwnerId(ctx)
	case todo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case todo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case todo.FieldExtraData:
		return m.OldExtraData(ctx)
	case todo.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Todo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TodoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case todo.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case todo.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case todo.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case todo.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case todo.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case todo.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case todo.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	case todo.FieldOwnerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerId(v)
		return nil
	case todo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case todo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case todo.FieldExtraData:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case todo.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Todo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TodoMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, todo.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TodoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case todo.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TodoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case todo.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Todo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TodoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(todo.FieldContent) {
		fields = append(fields, todo.FieldContent)
	}
	if m.FieldCleared(todo.FieldDueDate) {
		fields = append(fields, todo.FieldDueDate)
	}
	if m.FieldCleared(todo.FieldOwnerId) {
		fields = append(fields, todo.FieldOwnerId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TodoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TodoMutation) ClearField(name string) error {
	switch name {
	case todo.FieldContent:
		m.ClearContent()
		return nil
	case todo.FieldDueDate:
		m.ClearDueDate()
		return nil
	case todo.FieldOwnerId:
		m.ClearOwnerId()
		return nil
	}
	return fmt.Errorf("unknown Todo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TodoMutation) ResetField(name string) error {
	switch name {
	case todo.FieldTitle:
		m.ResetTitle()
		return nil
	case todo.FieldContent:
		m.ResetContent()
		return nil
	case todo.FieldStatus:
		m.ResetStatus()
		return nil
	case todo.FieldPriority:
		m.ResetPriority()
		return nil
	case todo.FieldDueDate:
		m.ResetDueDate()
		return nil
	case todo.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case todo.FieldPinned:
		m.ResetPinned()
		return nil
	case todo.FieldOwnerId:
		m.ResetOwnerId()
		return nil
	case todo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case todo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case todo.FieldExtraData:
		m.ResetExtraData()
		return nil
	case todo.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Todo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TodoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, todo.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TodoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case todo.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TodoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TodoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TodoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, todo.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TodoMutation) EdgeCleared(name string) bool {
	switch name {
	case todo.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TodoMutation) ClearEdge(name string) error {
	switch name {
	case todo.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Todo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TodoMutation) ResetEdge(name string) error {
	switch name {
	case todo.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Todo edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *string
	email           *string
	nickname        *string
	avatar          *string
	bio             *string
	isAdmin         *bool
	lastLoginIp     *string
	createdAt       *time.Time
	updatedAt       *time.Time
	lastLoginAt     *time.Time
	clearedFields   map[string]struct{}
	buckets         map[string]struct{}
	removedbuckets  map[string]struct{}
	clearedbuckets  bool
	files           map[string]struct{}
	removedfiles    map[string]struct{}
	clearedfiles    bool
	images          map[string]struct{}
	removedimages   map[string]struct{}
	clearedimages   bool
	keeps           map[string]struct{}
	removedkeeps    map[string]struct{}
	clearedkeeps    bool
	mindmaps        map[string]struct{}
	removedmindmaps map[string]struct{}
	clearedmindmaps bool
	moments         map[string]struct{}
	removedmoments  map[string]struct{}
	clearedmoments  bool
	todos           map[string]struct{}
	removedtodos    map[string]struct{}
	clearedtodos    bool
	group           *string
	clearedgroup    bool
	videos          map[string]struct{}
	removedvideos   map[string]struct{}
	clearedvideos   bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
}

// SetIsAdmin sets the "isAdmin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.isAdmin = &b
}

// IsAdmin returns the value of the "isAdmin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.isAdmin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "isAdmin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "isAdmin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.isAdmin = nil
}

// SetLastLoginIp sets the "lastLoginIp" field.
func (m *UserMutation) SetLastLoginIp(s string) {
	m.lastLoginIp = &s
}

// LastLoginIp returns the value of the "lastLoginIp" field in the mutation.
func (m *UserMutation) LastLoginIp() (r string, exists bool) {
	v := m.lastLoginIp
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIp returns the old "lastLoginIp" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginIp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIp: %w", err)
	}
	return oldValue.LastLoginIp, nil
}

// ResetLastLoginIp resets all changes to the "lastLoginIp" field.
func (m *UserMutation) ResetLastLoginIp() {
	m.lastLoginIp = nil
}

// SetGroupId sets the "groupId" field.
func (m *UserMutation) SetGroupId(s string) {
	m.group = &s
}

// GroupId returns the value of the "groupId" field in the mutation.
func (m *UserMutation) GroupId() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupId returns the old "groupId" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGroupId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupId: %w", err)
	}
	return oldValue.GroupId, nil
}

// ClearGroupId clears the value of the "groupId" field.
func (m *UserMutation) ClearGroupId() {
	m.group = nil
	m.clearedFields[user.FieldGroupId] = struct{}{}
}

// GroupIdCleared returns if the "groupId" field was cleared in this mutation.
func (m *UserMutation) GroupIdCleared() bool {
	_, ok := m.clearedFields[user.FieldGroupId]
	return ok
}

// ResetGroupId resets all changes to the "groupId" field.
func (m *UserMutation) ResetGroupId() {
	m.group = nil
	delete(m.clearedFields, user.FieldGroupId)
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetLastLoginAt sets the "lastLoginAt" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.lastLoginAt = &t
}

// LastLoginAt returns the value of the "lastLoginAt" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.lastLoginAt
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "lastLoginAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ResetLastLoginAt resets all changes to the "lastLoginAt" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.lastLoginAt = nil
}

// AddBucketIDs adds the "buckets" edge to the Bucket entity by ids.
func (m *UserMutation) AddBucketIDs(ids ...string) {
	if m.buckets == nil {
		m.buckets = make(map[string]struct{})
	}
	for i := range ids {
		m.buckets[ids[i]] = struct{}{}
	}
}

// ClearBuckets clears the "buckets" edge to the Bucket entity.
func (m *UserMutation) ClearBuckets() {
	m.clearedbuckets = true
}

// BucketsCleared reports if the "buckets" edge to the Bucket entity was cleared.
func (m *UserMutation) BucketsCleared() bool {
	return m.clearedbuckets
}

// RemoveBucketIDs removes the "buckets" edge to the Bucket entity by IDs.
func (m *UserMutation) RemoveBucketIDs(ids ...string) {
	if m.removedbuckets == nil {
		m.removedbuckets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.buckets, ids[i])
		m.removedbuckets[ids[i]] = struct{}{}
	}
}

// RemovedBuckets returns the removed IDs of the "buckets" edge to the Bucket entity.
func (m *UserMutation) RemovedBucketsIDs() (ids []string) {
	for id := range m.removedbuckets {
		ids = append(ids, id)
	}
	return
}

// BucketsIDs returns the "buckets" edge IDs in the mutation.
func (m *UserMutation) BucketsIDs() (ids []string) {
	for id := range m.buckets {
		ids = append(ids, id)
	}
	return
}

// ResetBuckets resets all changes to the "buckets" edge.
func (m *UserMutation) ResetBuckets() {
	m.buckets = nil
	m.clearedbuckets = false
	m.removedbuckets = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *UserMutation) AddImageIDs(ids ...string) {
	if m.images == nil {
		m.images = make(map[string]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *UserMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *UserMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *UserMutation) RemoveImageIDs(ids ...string) {
	if m.removedimages == nil {
		m.removedimages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *UserMutation) RemovedImagesIDs() (ids []string) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *UserMutation) ImagesIDs() (ids []string) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *UserMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddKeepIDs adds the "keeps" edge to the Keep entity by ids.
func (m *UserMutation) AddKeepIDs(ids ...string) {
	if m.keeps == nil {
		m.keeps = make(map[string]struct{})
	}
	for i := range ids {
		m.keeps[ids[i]] = struct{}{}
	}
}

// ClearKeeps clears the "keeps" edge to the Keep entity.
func (m *UserMutation) ClearKeeps() {
	m.clearedkeeps = true
}

// KeepsCleared reports if the "keeps" edge to the Keep entity was cleared.
func (m *UserMutation) KeepsCleared() bool {
	return m.clearedkeeps
}

// RemoveKeepIDs removes the "keeps" edge to the Keep entity by IDs.
func (m *UserMutation) RemoveKeepIDs(ids ...string) {
	if m.removedkeeps == nil {
		m.removedkeeps = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.keeps, ids[i])
		m.removedkeeps[ids[i]] = struct{}{}
	}
}

// RemovedKeeps returns the removed IDs of the "keeps" edge to the Keep entity.
func (m *UserMutation) RemovedKeepsIDs() (ids []string) {
	for id := range m.removedkeeps {
		ids = append(ids, id)
	}
	return
}

// KeepsIDs returns the "keeps" edge IDs in the mutation.
func (m *UserMutation) KeepsIDs() (ids []string) {
	for id := range m.keeps {
		ids = append(ids, id)
	}
	return
}

// ResetKeeps resets all changes to the "keeps" edge.
func (m *UserMutation) ResetKeeps() {
	m.keeps = nil
	m.clearedkeeps = false
	m.removedkeeps = nil
}

// AddMindmapIDs adds the "mindmaps" edge to the Mindmap entity by ids.
func (m *UserMutation) AddMindmapIDs(ids ...string) {
	if m.mindmaps == nil {
		m.mindmaps = make(map[string]struct{})
	}
	for i := range ids {
		m.mindmaps[ids[i]] = struct{}{}
	}
}

// ClearMindmaps clears the "mindmaps" edge to the Mindmap entity.
func (m *UserMutation) ClearMindmaps() {
	m.clearedmindmaps = true
}

// MindmapsCleared reports if the "mindmaps" edge to the Mindmap entity was cleared.
func (m *UserMutation) MindmapsCleared() bool {
	return m.clearedmindmaps
}

// RemoveMindmapIDs removes the "mindmaps" edge to the Mindmap entity by IDs.
func (m *UserMutation) RemoveMindmapIDs(ids ...string) {
	if m.removedmindmaps == nil {
		m.removedmindmaps = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mindmaps, ids[i])
		m.removedmindmaps[ids[i]] = struct{}{}
	}
}

// RemovedMindmaps returns the removed IDs of the "mindmaps" edge to the Mindmap entity.
func (m *UserMutation) RemovedMindmapsIDs() (ids []string) {
	for id := range m.removedmindmaps {
		ids = append(ids, id)
	}
	return
}

// MindmapsIDs returns the "mindmaps" edge IDs in the mutation.
func (m *UserMutation) MindmapsIDs() (ids []string) {
	for id := range m.mindmaps {
		ids = append(ids, id)
	}
	return
}

// ResetMindmaps resets all changes to the "mindmaps" edge.
func (m *UserMutation) ResetMindmaps() {
	m.mindmaps = nil
	m.clearedmindmaps = false
	m.removedmindmaps = nil
}

// AddMomentIDs adds the "moments" edge to the Moment entity by ids.
func (m *UserMutation) AddMomentIDs(ids ...string) {
	if m.moments == nil {
		m.moments = make(map[string]struct{})
	}
	for i := range ids {
		m.moments[ids[i]] = struct{}{}
	}
}

// ClearMoments clears the "moments" edge to the Moment entity.
func (m *UserMutation) ClearMoments() {
	m.clearedmoments = true
}

// MomentsCleared reports if the "moments" edge to the Moment entity was cleared.
func (m *UserMutation) MomentsCleared() bool {
	return m.clearedmoments
}

// RemoveMomentIDs removes the "moments" edge to the Moment entity by IDs.
func (m *UserMutation) RemoveMomentIDs(ids ...string) {
	if m.removedmoments == nil {
		m.removedmoments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.moments, ids[i])
		m.removedmoments[ids[i]] = struct{}{}
	}
}

// RemovedMoments returns the removed IDs of the "moments" edge to the Moment entity.
func (m *UserMutation) RemovedMomentsIDs() (ids []string) {
	for id := range m.removedmoments {
		ids = append(ids, id)
	}
	return
}

// MomentsIDs returns the "moments" edge IDs in the mutation.
func (m *UserMutation) MomentsIDs() (ids []string) {
	for id := range m.moments {
		ids = append(ids, id)
	}
	return
}

// ResetMoments resets all changes to the "moments" edge.
func (m *UserMutation) ResetMoments() {
	m.moments = nil
	m.clearedmoments = false
	m.removedmoments = nil
}

// AddTodoIDs adds the "todos" edge to the Todo entity by ids.
func (m *UserMutation) AddTodoIDs(ids ...string) {
	if m.todos == nil {
		m.todos = make(map[string]struct{})
	}
	for i := range ids {
		m.todos[ids[i]] = struct{}{}
	}
}

// ClearTodos clears the "todos" edge to the Todo entity.
func (m *UserMutation) ClearTodos() {
	m.clearedtodos = true
}

// TodosCleared reports if the "todos" edge to the Todo entity was cleared.
func (m *UserMutation) TodosCleared() bool {
	return m.clearedtodos
}

// RemoveTodoIDs removes the "todos" edge to the Todo entity by IDs.
func (m *UserMutation) RemoveTodoIDs(ids ...string) {
	if m.removedtodos == nil {
		m.removedtodos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.todos, ids[i])
		m.removedtodos[ids[i]] = struct{}{}
	}
}

// RemovedTodos returns the removed IDs of the "todos" edge to the Todo entity.
func (m *UserMutation) RemovedTodosIDs() (ids []string) {
	for id := range m.removedtodos {
		ids = append(ids, id)
	}
	return
}

// TodosIDs returns the "todos" edge IDs in the mutation.
func (m *UserMutation) TodosIDs() (ids []string) {
	for id := range m.todos {
		ids = append(ids, id)
	}
	return
}

// ResetTodos resets all changes to the "todos" edge.
func (m *UserMutation) ResetTodos() {
	m.todos = nil
	m.clearedtodos = false
	m.removedtodos = nil
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *UserMutation) SetGroupID(id string) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[user.FieldGroupId] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserMutation) GroupCleared() bool {
	return m.GroupIdCleared() || m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *UserMutation) GroupID() (id string, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserMutation) GroupIDs() (ids []string) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddVideoIDs adds the "videos" edge to the Video entity by ids.
func (m *UserMutation) AddVideoIDs(ids ...string) {
	if m.videos == nil {
		m.videos = make(map[string]struct{})
	}
	for i := range ids {
		m.videos[ids[i]] = struct{}{}
	}
}

// ClearVideos clears the "videos" edge to the Video entity.
func (m *UserMutation) ClearVideos() {
	m.clearedvideos = true
}

// VideosCleared reports if the "videos" edge to the Video entity was cleared.
func (m *UserMutation) VideosCleared() bool {
	return m.clearedvideos
}

// RemoveVideoIDs removes the "videos" edge to the Video entity by IDs.
func (m *UserMutation) RemoveVideoIDs(ids ...string) {
	if m.removedvideos == nil {
		m.removedvideos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.videos, ids[i])
		m.removedvideos[ids[i]] = struct{}{}
	}
}

// RemovedVideos returns the removed IDs of the "videos" edge to the Video entity.
func (m *UserMutation) RemovedVideosIDs() (ids []string) {
	for id := range m.removedvideos {
		ids = append(ids, id)
	}
	return
}

// VideosIDs returns the "videos" edge IDs in the mutation.
func (m *UserMutation) VideosIDs() (ids []string) {
	for id := range m.videos {
		ids = append(ids, id)
	}
	return
}

// ResetVideos resets all changes to the "videos" edge.
func (m *UserMutation) ResetVideos() {
	m.videos = nil
	m.clearedvideos = false
	m.removedvideos = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.isAdmin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.lastLoginIp != nil {
		fields = append(fields, user.FieldLastLoginIp)
	}
	if m.group != nil {
		fields = append(fields, user.FieldGroupId)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.lastLoginAt != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldBio:
		return m.Bio()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldLastLoginIp:
		return m.LastLoginIp()
	case user.FieldGroupId:
		return m.GroupId()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldLastLoginIp:
		return m.OldLastLoginIp(ctx)
	case user.FieldGroupId:
		return m.OldGroupId(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldLastLoginIp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIp(v)
		return nil
	case user.FieldGroupId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupId(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldGroupId) {
		fields = append(fields, user.FieldGroupId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldGroupId:
		m.ClearGroupId()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldLastLoginIp:
		m.ResetLastLoginIp()
		return nil
	case user.FieldGroupId:
		m.ResetGroupId()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.buckets != nil {
		edges = append(edges, user.EdgeBuckets)
	}
	if m.files != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.images != nil {
		edges = append(edges, user.EdgeImages)
	}
	if m.keeps != nil {
		edges = append(edges, user.EdgeKeeps)
	}
	if m.mindmaps != nil {
		edges = append(edges, user.EdgeMindmaps)
	}
	if m.moments != nil {
		edges = append(edges, user.EdgeMoments)
	}
	if m.todos != nil {
		edges = append(edges, user.EdgeTodos)
	}
	if m.group != nil {
		edges = append(edges, user.EdgeGroup)
	}
	if m.videos != nil {
		edges = append(edges, user.EdgeVideos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBuckets:
		ids := make([]ent.Value, 0, len(m.buckets))
		for id := range m.buckets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeKeeps:
		ids := make([]ent.Value, 0, len(m.keeps))
		for id := range m.keeps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMindmaps:
		ids := make([]ent.Value, 0, len(m.mindmaps))
		for id := range m.mindmaps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMoments:
		ids := make([]ent.Value, 0, len(m.moments))
		for id := range m.moments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTodos:
		ids := make([]ent.Value, 0, len(m.todos))
		for id := range m.todos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeVideos:
		ids := make([]ent.Value, 0, len(m.videos))
		for id := range m.videos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedbuckets != nil {
		edges = append(edges, user.EdgeBuckets)
	}
	if m.removedfiles != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.removedimages != nil {
		edges = append(edges, user.EdgeImages)
	}
	if m.removedkeeps != nil {
		edges = append(edges, user.EdgeKeeps)
	}
	if m.removedmindmaps != nil {
		edges = append(edges, user.EdgeMindmaps)
	}
	if m.removedmoments != nil {
		edges = append(edges, user.EdgeMoments)
	}
	if m.removedtodos != nil {
		edges = append(edges, user.EdgeTodos)
	}
	if m.removedvideos != nil {
		edges = append(edges, user.EdgeVideos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBuckets:
		ids := make([]ent.Value, 0, len(m.removedbuckets))
		for id := range m.removedbuckets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeKeeps:
		ids := make([]ent.Value, 0, len(m.removedkeeps))
		for id := range m.removedkeeps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMindmaps:
		ids := make([]ent.Value, 0, len(m.removedmindmaps))
		for id := range m.removedmindmaps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMoments:
		ids := make([]ent.Value, 0, len(m.removedmoments))
		for id := range m.removedmoments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTodos:
		ids := make([]ent.Value, 0, len(m.removedtodos))
		for id := range m.removedtodos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVideos:
		ids := make([]ent.Value, 0, len(m.removedvideos))
		for id := range m.removedvideos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedbuckets {
		edges = append(edges, user.EdgeBuckets)
	}
	if m.clearedfiles {
		edges = append(edges, user.EdgeFiles)
	}
	if m.clearedimages {
		edges = append(edges, user.EdgeImages)
	}
	if m.clearedkeeps {
		edges = append(edges, user.EdgeKeeps)
	}
	if m.clearedmindmaps {
		edges = append(edges, user.EdgeMindmaps)
	}
	if m.clearedmoments {
		edges = append(edges, user.EdgeMoments)
	}
	if m.clearedtodos {
		edges = append(edges, user.EdgeTodos)
	}
	if m.clearedgroup {
		edges = append(edges, user.EdgeGroup)
	}
	if m.clearedvideos {
		edges = append(edges, user.EdgeVideos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBuckets:
		return m.clearedbuckets
	case user.EdgeFiles:
		return m.clearedfiles
	case user.EdgeImages:
		return m.clearedimages
	case user.EdgeKeeps:
		return m.clearedkeeps
	case user.EdgeMindmaps:
		return m.clearedmindmaps
	case user.EdgeMoments:
		return m.clearedmoments
	case user.EdgeTodos:
		return m.clearedtodos
	case user.EdgeGroup:
		return m.clearedgroup
	case user.EdgeVideos:
		return m.clearedvideos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBuckets:
		m.ResetBuckets()
		return nil
	case user.EdgeFiles:
		m.ResetFiles()
		return nil
	case user.EdgeImages:
		m.ResetImages()
		return nil
	case user.EdgeKeeps:
		m.ResetKeeps()
		return nil
	case user.EdgeMindmaps:
		m.ResetMindmaps()
		return nil
	case user.EdgeMoments:
		m.ResetMoments()
		return nil
	case user.EdgeTodos:
		m.ResetTodos()
		return nil
	case user.EdgeGroup:
		m.ResetGroup()
		return nil
	case user.EdgeVideos:
		m.ResetVideos()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VideoMutation represents an operation that mutates the Video nodes in the graph.
type VideoMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	hash                 *string
	size                 *int
	addsize              *int
	isPublic             *bool
	createdAt            *time.Time
	updatedAt            *time.Time
	duration             *int32
	addduration          *int32
	name                 *string
	_type                *string
	extraData            *json.RawMessage
	appendextraData      json.RawMessage
	category             *string
	clearedFields        map[string]struct{}
	moment_videos        map[uint]struct{}
	removedmoment_videos map[uint]struct{}
	clearedmoment_videos bool
	file                 *string
	clearedfile          bool
	poster               *string
	clearedposter        bool
	user                 *string
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Video, error)
	predicates           []predicate.Video
}

var _ ent.Mutation = (*VideoMutation)(nil)

// videoOption allows management of the mutation configuration using functional options.
type videoOption func(*VideoMutation)

// newVideoMutation creates new mutation for the Video entity.
func newVideoMutation(c config, op Op, opts ...videoOption) *VideoMutation {
	m := &VideoMutation{
		config:        c,
		op:            op,
		typ:           TypeVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoID sets the ID field of the mutation.
func withVideoID(id string) videoOption {
	return func(m *VideoMutation) {
		var (
			err   error
			once  sync.Once
			value *Video
		)
		m.oldValue = func(ctx context.Context) (*Video, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Video.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideo sets the old Video of the mutation.
func withVideo(node *Video) videoOption {
	return func(m *VideoMutation) {
		m.oldValue = func(context.Context) (*Video, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Video entities.
func (m *VideoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Video.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHash sets the "hash" field.
func (m *VideoMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *VideoMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *VideoMutation) ResetHash() {
	m.hash = nil
}

// SetSize sets the "size" field.
func (m *VideoMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VideoMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VideoMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VideoMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VideoMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetIsPublic sets the "isPublic" field.
func (m *VideoMutation) SetIsPublic(b bool) {
	m.isPublic = &b
}

// IsPublic returns the value of the "isPublic" field in the mutation.
func (m *VideoMutation) IsPublic() (r bool, exists bool) {
	v := m.isPublic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "isPublic" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "isPublic" field.
func (m *VideoMutation) ResetIsPublic() {
	m.isPublic = nil
}

// SetPosterId sets the "posterId" field.
func (m *VideoMutation) SetPosterId(s string) {
	m.poster = &s
}

// PosterId returns the value of the "posterId" field in the mutation.
func (m *VideoMutation) PosterId() (r string, exists bool) {
	v := m.poster
	if v == nil {
		return
	}
	return *v, true
}

// OldPosterId returns the old "posterId" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldPosterId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosterId: %w", err)
	}
	return oldValue.PosterId, nil
}

// ClearPosterId clears the value of the "posterId" field.
func (m *VideoMutation) ClearPosterId() {
	m.poster = nil
	m.clearedFields[video.FieldPosterId] = struct{}{}
}

// PosterIdCleared returns if the "posterId" field was cleared in this mutation.
func (m *VideoMutation) PosterIdCleared() bool {
	_, ok := m.clearedFields[video.FieldPosterId]
	return ok
}

// ResetPosterId resets all changes to the "posterId" field.
func (m *VideoMutation) ResetPosterId() {
	m.poster = nil
	delete(m.clearedFields, video.FieldPosterId)
}

// SetFileId sets the "fileId" field.
func (m *VideoMutation) SetFileId(s string) {
	m.file = &s
}

// FileId returns the value of the "fileId" field in the mutation.
func (m *VideoMutation) FileId() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileId returns the old "fileId" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldFileId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileId: %w", err)
	}
	return oldValue.FileId, nil
}

// ClearFileId clears the value of the "fileId" field.
func (m *VideoMutation) ClearFileId() {
	m.file = nil
	m.clearedFields[video.FieldFileId] = struct{}{}
}

// FileIdCleared returns if the "fileId" field was cleared in this mutation.
func (m *VideoMutation) FileIdCleared() bool {
	_, ok := m.clearedFields[video.FieldFileId]
	return ok
}

// ResetFileId resets all changes to the "fileId" field.
func (m *VideoMutation) ResetFileId() {
	m.file = nil
	delete(m.clearedFields, video.FieldFileId)
}

// SetUploadedBy sets the "uploadedBy" field.
func (m *VideoMutation) SetUploadedBy(s string) {
	m.user = &s
}

// UploadedBy returns the value of the "uploadedBy" field in the mutation.
func (m *VideoMutation) UploadedBy() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedBy returns the old "uploadedBy" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUploadedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedBy: %w", err)
	}
	return oldValue.UploadedBy, nil
}

// ClearUploadedBy clears the value of the "uploadedBy" field.
func (m *VideoMutation) ClearUploadedBy() {
	m.user = nil
	m.clearedFields[video.FieldUploadedBy] = struct{}{}
}

// UploadedByCleared returns if the "uploadedBy" field was cleared in this mutation.
func (m *VideoMutation) UploadedByCleared() bool {
	_, ok := m.clearedFields[video.FieldUploadedBy]
	return ok
}

// ResetUploadedBy resets all changes to the "uploadedBy" field.
func (m *VideoMutation) ResetUploadedBy() {
	m.user = nil
	delete(m.clearedFields, video.FieldUploadedBy)
}

// SetCreatedAt sets the "createdAt" field.
func (m *VideoMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *VideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *VideoMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *VideoMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *VideoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *VideoMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDuration sets the "duration" field.
func (m *VideoMutation) SetDuration(i int32) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VideoMutation) Duration() (r int32, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDuration(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *VideoMutation) AddDuration(i int32) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *VideoMutation) AddedDuration() (r int32, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *VideoMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetName sets the "name" field.
func (m *VideoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VideoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VideoMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *VideoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *VideoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *VideoMutation) ResetType() {
	m._type = nil
}

// SetExtraData sets the "extraData" field.
func (m *VideoMutation) SetExtraData(jm json.RawMessage) {
	m.extraData = &jm
	m.appendextraData = nil
}

// ExtraData returns the value of the "extraData" field in the mutation.
func (m *VideoMutation) ExtraData() (r json.RawMessage, exists bool) {
	v := m.extraData
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extraData" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldExtraData(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// AppendExtraData adds jm to the "extraData" field.
func (m *VideoMutation) AppendExtraData(jm json.RawMessage) {
	m.appendextraData = append(m.appendextraData, jm...)
}

// AppendedExtraData returns the list of values that were appended to the "extraData" field in this mutation.
func (m *VideoMutation) AppendedExtraData() (json.RawMessage, bool) {
	if len(m.appendextraData) == 0 {
		return nil, false
	}
	return m.appendextraData, true
}

// ResetExtraData resets all changes to the "extraData" field.
func (m *VideoMutation) ResetExtraData() {
	m.extraData = nil
	m.appendextraData = nil
}

// SetCategory sets the "category" field.
func (m *VideoMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *VideoMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *VideoMutation) ResetCategory() {
	m.category = nil
}

// AddMomentVideoIDs adds the "moment_videos" edge to the MomentVideo entity by ids.
func (m *VideoMutation) AddMomentVideoIDs(ids ...uint) {
	if m.moment_videos == nil {
		m.moment_videos = make(map[uint]struct{})
	}
	for i := range ids {
		m.moment_videos[ids[i]] = struct{}{}
	}
}

// ClearMomentVideos clears the "moment_videos" edge to the MomentVideo entity.
func (m *VideoMutation) ClearMomentVideos() {
	m.clearedmoment_videos = true
}

// MomentVideosCleared reports if the "moment_videos" edge to the MomentVideo entity was cleared.
func (m *VideoMutation) MomentVideosCleared() bool {
	return m.clearedmoment_videos
}

// RemoveMomentVideoIDs removes the "moment_videos" edge to the MomentVideo entity by IDs.
func (m *VideoMutation) RemoveMomentVideoIDs(ids ...uint) {
	if m.removedmoment_videos == nil {
		m.removedmoment_videos = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.moment_videos, ids[i])
		m.removedmoment_videos[ids[i]] = struct{}{}
	}
}

// RemovedMomentVideos returns the removed IDs of the "moment_videos" edge to the MomentVideo entity.
func (m *VideoMutation) RemovedMomentVideosIDs() (ids []uint) {
	for id := range m.removedmoment_videos {
		ids = append(ids, id)
	}
	return
}

// MomentVideosIDs returns the "moment_videos" edge IDs in the mutation.
func (m *VideoMutation) MomentVideosIDs() (ids []uint) {
	for id := range m.moment_videos {
		ids = append(ids, id)
	}
	return
}

// ResetMomentVideos resets all changes to the "moment_videos" edge.
func (m *VideoMutation) ResetMomentVideos() {
	m.moment_videos = nil
	m.clearedmoment_videos = false
	m.removedmoment_videos = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *VideoMutation) SetFileID(id string) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *VideoMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[video.FieldFileId] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *VideoMutation) FileCleared() bool {
	return m.FileIdCleared() || m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *VideoMutation) FileID() (id string, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) FileIDs() (ids []string) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *VideoMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// SetPosterID sets the "poster" edge to the File entity by id.
func (m *VideoMutation) SetPosterID(id string) {
	m.poster = &id
}

// ClearPoster clears the "poster" edge to the File entity.
func (m *VideoMutation) ClearPoster() {
	m.clearedposter = true
	m.clearedFields[video.FieldPosterId] = struct{}{}
}

// PosterCleared reports if the "poster" edge to the File entity was cleared.
func (m *VideoMutation) PosterCleared() bool {
	return m.PosterIdCleared() || m.clearedposter
}

// PosterID returns the "poster" edge ID in the mutation.
func (m *VideoMutation) PosterID() (id string, exists bool) {
	if m.poster != nil {
		return *m.poster, true
	}
	return
}

// PosterIDs returns the "poster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PosterID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) PosterIDs() (ids []string) {
	if id := m.poster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPoster resets all changes to the "poster" edge.
func (m *VideoMutation) ResetPoster() {
	m.poster = nil
	m.clearedposter = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VideoMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VideoMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[video.FieldUploadedBy] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VideoMutation) UserCleared() bool {
	return m.UploadedByCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VideoMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VideoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VideoMutation builder.
func (m *VideoMutation) Where(ps ...predicate.Video) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Video, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Video).
func (m *VideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.hash != nil {
		fields = append(fields, video.FieldHash)
	}
	if m.size != nil {
		fields = append(fields, video.FieldSize)
	}
	if m.isPublic != nil {
		fields = append(fields, video.FieldIsPublic)
	}
	if m.poster != nil {
		fields = append(fields, video.FieldPosterId)
	}
	if m.file != nil {
		fields = append(fields, video.FieldFileId)
	}
	if m.user != nil {
		fields = append(fields, video.FieldUploadedBy)
	}
	if m.createdAt != nil {
		fields = append(fields, video.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, video.FieldUpdatedAt)
	}
	if m.duration != nil {
		fields = append(fields, video.FieldDuration)
	}
	if m.name != nil {
		fields = append(fields, video.FieldName)
	}
	if m._type != nil {
		fields = append(fields, video.FieldType)
	}
	if m.extraData != nil {
		fields = append(fields, video.FieldExtraData)
	}
	if m.category != nil {
		fields = append(fields, video.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case video.FieldHash:
		return m.Hash()
	case video.FieldSize:
		return m.Size()
	case video.FieldIsPublic:
		return m.IsPublic()
	case video.FieldPosterId:
		return m.PosterId()
	case video.FieldFileId:
		return m.FileId()
	case video.FieldUploadedBy:
		return m.UploadedBy()
	case video.FieldCreatedAt:
		return m.CreatedAt()
	case video.FieldUpdatedAt:
		return m.UpdatedAt()
	case video.FieldDuration:
		return m.Duration()
	case video.FieldName:
		return m.Name()
	case video.FieldType:
		return m.GetType()
	case video.FieldExtraData:
		return m.ExtraData()
	case video.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case video.FieldHash:
		return m.OldHash(ctx)
	case video.FieldSize:
		return m.OldSize(ctx)
	case video.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case video.FieldPosterId:
		return m.OldPosterId(ctx)
	case video.FieldFileId:
		return m.OldFileId(ctx)
	case video.FieldUploadedBy:
		return m.OldUploadedBy(ctx)
	case video.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case video.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case video.FieldDuration:
		return m.OldDuration(ctx)
	case video.FieldName:
		return m.OldName(ctx)
	case video.FieldType:
		return m.OldType(ctx)
	case video.FieldExtraData:
		return m.OldExtraData(ctx)
	case video.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Video field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case video.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case video.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case video.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case video.FieldPosterId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosterId(v)
		return nil
	case video.FieldFileId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileId(v)
		return nil
	case video.FieldUploadedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedBy(v)
		return nil
	case video.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case video.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case video.FieldDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case video.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case video.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case video.FieldExtraData:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	case video.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, video.FieldSize)
	}
	if m.addduration != nil {
		fields = append(fields, video.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case video.FieldSize:
		return m.AddedSize()
	case video.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case video.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case video.FieldDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Video numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(video.FieldPosterId) {
		fields = append(fields, video.FieldPosterId)
	}
	if m.FieldCleared(video.FieldFileId) {
		fields = append(fields, video.FieldFileId)
	}
	if m.FieldCleared(video.FieldUploadedBy) {
		fields = append(fields, video.FieldUploadedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoMutation) ClearField(name string) error {
	switch name {
	case video.FieldPosterId:
		m.ClearPosterId()
		return nil
	case video.FieldFileId:
		m.ClearFileId()
		return nil
	case video.FieldUploadedBy:
		m.ClearUploadedBy()
		return nil
	}
	return fmt.Errorf("unknown Video nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoMutation) ResetField(name string) error {
	switch name {
	case video.FieldHash:
		m.ResetHash()
		return nil
	case video.FieldSize:
		m.ResetSize()
		return nil
	case video.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case video.FieldPosterId:
		m.ResetPosterId()
		return nil
	case video.FieldFileId:
		m.ResetFileId()
		return nil
	case video.FieldUploadedBy:
		m.ResetUploadedBy()
		return nil
	case video.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case video.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case video.FieldDuration:
		m.ResetDuration()
		return nil
	case video.FieldName:
		m.ResetName()
		return nil
	case video.FieldType:
		m.ResetType()
		return nil
	case video.FieldExtraData:
		m.ResetExtraData()
		return nil
	case video.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.moment_videos != nil {
		edges = append(edges, video.EdgeMomentVideos)
	}
	if m.file != nil {
		edges = append(edges, video.EdgeFile)
	}
	if m.poster != nil {
		edges = append(edges, video.EdgePoster)
	}
	if m.user != nil {
		edges = append(edges, video.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeMomentVideos:
		ids := make([]ent.Value, 0, len(m.moment_videos))
		for id := range m.moment_videos {
			ids = append(ids, id)
		}
		return ids
	case video.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgePoster:
		if id := m.poster; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmoment_videos != nil {
		edges = append(edges, video.EdgeMomentVideos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeMomentVideos:
		ids := make([]ent.Value, 0, len(m.removedmoment_videos))
		for id := range m.removedmoment_videos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmoment_videos {
		edges = append(edges, video.EdgeMomentVideos)
	}
	if m.clearedfile {
		edges = append(edges, video.EdgeFile)
	}
	if m.clearedposter {
		edges = append(edges, video.EdgePoster)
	}
	if m.cleareduser {
		edges = append(edges, video.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoMutation) EdgeCleared(name string) bool {
	switch name {
	case video.EdgeMomentVideos:
		return m.clearedmoment_videos
	case video.EdgeFile:
		return m.clearedfile
	case video.EdgePoster:
		return m.clearedposter
	case video.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoMutation) ClearEdge(name string) error {
	switch name {
	case video.EdgeFile:
		m.ClearFile()
		return nil
	case video.EdgePoster:
		m.ClearPoster()
		return nil
	case video.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Video unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoMutation) ResetEdge(name string) error {
	switch name {
	case video.EdgeMomentVideos:
		m.ResetMomentVideos()
		return nil
	case video.EdgeFile:
		m.ResetFile()
		return nil
	case video.EdgePoster:
		m.ResetPoster()
		return nil
	case video.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Video edge %s", name)
}
