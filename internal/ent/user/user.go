// Code generated by ent, DO NOT EDIT.

package user

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the user type in the database.
	Label = "user"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldEmail holds the string denoting the email field in the database.
	FieldEmail = "email"
	// FieldNickname holds the string denoting the nickname field in the database.
	FieldNickname = "nickname"
	// FieldAvatar holds the string denoting the avatar field in the database.
	FieldAvatar = "avatar"
	// FieldBio holds the string denoting the bio field in the database.
	FieldBio = "bio"
	// FieldIsAdmin holds the string denoting the isadmin field in the database.
	FieldIsAdmin = "isAdmin"
	// FieldLastLoginIp holds the string denoting the lastloginip field in the database.
	FieldLastLoginIp = "lastLoginIp"
	// FieldGroupId holds the string denoting the groupid field in the database.
	FieldGroupId = "groupId"
	// FieldCreatedAt holds the string denoting the createdat field in the database.
	FieldCreatedAt = "createdAt"
	// FieldUpdatedAt holds the string denoting the updatedat field in the database.
	FieldUpdatedAt = "updatedAt"
	// FieldLastLoginAt holds the string denoting the lastloginat field in the database.
	FieldLastLoginAt = "lastLoginAt"
	// EdgeBuckets holds the string denoting the buckets edge name in mutations.
	EdgeBuckets = "buckets"
	// EdgeFiles holds the string denoting the files edge name in mutations.
	EdgeFiles = "files"
	// EdgeImages holds the string denoting the images edge name in mutations.
	EdgeImages = "images"
	// EdgeKeeps holds the string denoting the keeps edge name in mutations.
	EdgeKeeps = "keeps"
	// EdgeMindmaps holds the string denoting the mindmaps edge name in mutations.
	EdgeMindmaps = "mindmaps"
	// EdgeMoments holds the string denoting the moments edge name in mutations.
	EdgeMoments = "moments"
	// EdgeTodos holds the string denoting the todos edge name in mutations.
	EdgeTodos = "todos"
	// EdgeGroup holds the string denoting the group edge name in mutations.
	EdgeGroup = "group"
	// EdgeVideos holds the string denoting the videos edge name in mutations.
	EdgeVideos = "videos"
	// Table holds the table name of the user in the database.
	Table = "users"
	// BucketsTable is the table that holds the buckets relation/edge.
	BucketsTable = "buckets"
	// BucketsInverseTable is the table name for the Bucket entity.
	// It exists in this package in order to avoid circular dependency with the "bucket" package.
	BucketsInverseTable = "buckets"
	// BucketsColumn is the table column denoting the buckets relation/edge.
	BucketsColumn = "ownerId"
	// FilesTable is the table that holds the files relation/edge.
	FilesTable = "files"
	// FilesInverseTable is the table name for the File entity.
	// It exists in this package in order to avoid circular dependency with the "file" package.
	FilesInverseTable = "files"
	// FilesColumn is the table column denoting the files relation/edge.
	FilesColumn = "uploadedBy"
	// ImagesTable is the table that holds the images relation/edge.
	ImagesTable = "images"
	// ImagesInverseTable is the table name for the Image entity.
	// It exists in this package in order to avoid circular dependency with the "image" package.
	ImagesInverseTable = "images"
	// ImagesColumn is the table column denoting the images relation/edge.
	ImagesColumn = "uploadedBy"
	// KeepsTable is the table that holds the keeps relation/edge.
	KeepsTable = "keeps"
	// KeepsInverseTable is the table name for the Keep entity.
	// It exists in this package in order to avoid circular dependency with the "keep" package.
	KeepsInverseTable = "keeps"
	// KeepsColumn is the table column denoting the keeps relation/edge.
	KeepsColumn = "ownerId"
	// MindmapsTable is the table that holds the mindmaps relation/edge.
	MindmapsTable = "mindmaps"
	// MindmapsInverseTable is the table name for the Mindmap entity.
	// It exists in this package in order to avoid circular dependency with the "mindmap" package.
	MindmapsInverseTable = "mindmaps"
	// MindmapsColumn is the table column denoting the mindmaps relation/edge.
	MindmapsColumn = "ownerId"
	// MomentsTable is the table that holds the moments relation/edge.
	MomentsTable = "moments"
	// MomentsInverseTable is the table name for the Moment entity.
	// It exists in this package in order to avoid circular dependency with the "moment" package.
	MomentsInverseTable = "moments"
	// MomentsColumn is the table column denoting the moments relation/edge.
	MomentsColumn = "ownerId"
	// TodosTable is the table that holds the todos relation/edge.
	TodosTable = "todos"
	// TodosInverseTable is the table name for the Todo entity.
	// It exists in this package in order to avoid circular dependency with the "todo" package.
	TodosInverseTable = "todos"
	// TodosColumn is the table column denoting the todos relation/edge.
	TodosColumn = "ownerId"
	// GroupTable is the table that holds the group relation/edge.
	GroupTable = "users"
	// GroupInverseTable is the table name for the Group entity.
	// It exists in this package in order to avoid circular dependency with the "group" package.
	GroupInverseTable = "groups"
	// GroupColumn is the table column denoting the group relation/edge.
	GroupColumn = "groupId"
	// VideosTable is the table that holds the videos relation/edge.
	VideosTable = "videos"
	// VideosInverseTable is the table name for the Video entity.
	// It exists in this package in order to avoid circular dependency with the "video" package.
	VideosInverseTable = "videos"
	// VideosColumn is the table column denoting the videos relation/edge.
	VideosColumn = "uploadedBy"
)

// Columns holds all SQL columns for user fields.
var Columns = []string{
	FieldID,
	FieldEmail,
	FieldNickname,
	FieldAvatar,
	FieldBio,
	FieldIsAdmin,
	FieldLastLoginIp,
	FieldGroupId,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldLastLoginAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the User queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByEmail orders the results by the email field.
func ByEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEmail, opts...).ToFunc()
}

// ByNickname orders the results by the nickname field.
func ByNickname(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNickname, opts...).ToFunc()
}

// ByAvatar orders the results by the avatar field.
func ByAvatar(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAvatar, opts...).ToFunc()
}

// ByBio orders the results by the bio field.
func ByBio(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBio, opts...).ToFunc()
}

// ByIsAdmin orders the results by the isAdmin field.
func ByIsAdmin(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsAdmin, opts...).ToFunc()
}

// ByLastLoginIp orders the results by the lastLoginIp field.
func ByLastLoginIp(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLastLoginIp, opts...).ToFunc()
}

// ByGroupId orders the results by the groupId field.
func ByGroupId(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldGroupId, opts...).ToFunc()
}

// ByCreatedAt orders the results by the createdAt field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updatedAt field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByLastLoginAt orders the results by the lastLoginAt field.
func ByLastLoginAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLastLoginAt, opts...).ToFunc()
}

// ByBucketsCount orders the results by buckets count.
func ByBucketsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newBucketsStep(), opts...)
	}
}

// ByBuckets orders the results by buckets terms.
func ByBuckets(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newBucketsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByFilesCount orders the results by files count.
func ByFilesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newFilesStep(), opts...)
	}
}

// ByFiles orders the results by files terms.
func ByFiles(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFilesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByImagesCount orders the results by images count.
func ByImagesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newImagesStep(), opts...)
	}
}

// ByImages orders the results by images terms.
func ByImages(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newImagesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByKeepsCount orders the results by keeps count.
func ByKeepsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newKeepsStep(), opts...)
	}
}

// ByKeeps orders the results by keeps terms.
func ByKeeps(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newKeepsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByMindmapsCount orders the results by mindmaps count.
func ByMindmapsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newMindmapsStep(), opts...)
	}
}

// ByMindmaps orders the results by mindmaps terms.
func ByMindmaps(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newMindmapsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByMomentsCount orders the results by moments count.
func ByMomentsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newMomentsStep(), opts...)
	}
}

// ByMoments orders the results by moments terms.
func ByMoments(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newMomentsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTodosCount orders the results by todos count.
func ByTodosCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTodosStep(), opts...)
	}
}

// ByTodos orders the results by todos terms.
func ByTodos(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTodosStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByGroupField orders the results by group field.
func ByGroupField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newGroupStep(), sql.OrderByField(field, opts...))
	}
}

// ByVideosCount orders the results by videos count.
func ByVideosCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newVideosStep(), opts...)
	}
}

// ByVideos orders the results by videos terms.
func ByVideos(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newVideosStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newBucketsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(BucketsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, BucketsTable, BucketsColumn),
	)
}
func newFilesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FilesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, FilesTable, FilesColumn),
	)
}
func newImagesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ImagesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ImagesTable, ImagesColumn),
	)
}
func newKeepsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(KeepsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, KeepsTable, KeepsColumn),
	)
}
func newMindmapsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(MindmapsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, MindmapsTable, MindmapsColumn),
	)
}
func newMomentsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(MomentsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, MomentsTable, MomentsColumn),
	)
}
func newTodosStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TodosInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, TodosTable, TodosColumn),
	)
}
func newGroupStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(GroupInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, GroupTable, GroupColumn),
	)
}
func newVideosStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(VideosInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, VideosTable, VideosColumn),
	)
}
